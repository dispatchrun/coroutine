// Code generated by coroc. DO NOT EDIT

//go:build durable

package testdata

import (
	"github.com/stealthrocket/coroutine"
	serde "github.com/stealthrocket/coroutine/serde"
	runtime "runtime"
	sync "sync"
	atomic "sync/atomic"
	syscall "syscall"
	time "time"
	unsafe "unsafe"
)

func Identity(n int) {
	_c := coroutine.LoadContext[int, any]()
	_f, _fp := _c.Push()
	if _f.IP > 0 {
		if _v := _f.Get(0); _v != nil {
			n = _v.(int)
		}
	}
	defer func() {
		if _c.Unwinding() {
			_f.Set(0, n)
			_c.Store(_fp, _f)
		} else {
			_c.Pop()
		}
	}()
	coroutine.Yield[int, any](n)
}

func SquareGenerator(n int) {
	_c := coroutine.LoadContext[int, any]()
	_f, _fp := _c.Push()
	var _o0 int
	var _o1 bool
	if _f.IP > 0 {
		if _v := _f.Get(0); _v != nil {
			n = _v.(int)
		}
		if _v := _f.Get(1); _v != nil {
			_o0 = _v.(int)
		}
		if _v := _f.Get(2); _v != nil {
			_o1 = _v.(bool)
		}
	}
	defer func() {
		if _c.Unwinding() {
			_f.Set(0, n)
			_f.Set(1, _o0)
			_f.Set(2, _o1)
			_c.Store(_fp, _f)
		} else {
			_c.Pop()
		}
	}()
	switch {
	case _f.IP < 2:
		_o0 = 1
		_f.IP = 2
		fallthrough
	case _f.IP < 5:
	_l0:
		for ; ; _o0, _f.IP = _o0+1, 2 {
			switch {
			case _f.IP < 4:
				switch {
				case _f.IP < 3:
					_o1 = !(_o0 <= n)
					_f.IP = 3
					fallthrough
				case _f.IP < 4:
					if _o1 {
						break _l0
					}
				}
				_f.IP = 4
				fallthrough
			case _f.IP < 5:
				coroutine.Yield[int, any](_o0 * _o0)
			}
		}
	}
}

func SquareGeneratorTwice(n int) {
	_c := coroutine.LoadContext[int, any]()
	_f, _fp := _c.Push()
	if _f.IP > 0 {
		if _v := _f.Get(0); _v != nil {
			n = _v.(int)
		}
	}
	defer func() {
		if _c.Unwinding() {
			_f.Set(0, n)
			_c.Store(_fp, _f)
		} else {
			_c.Pop()
		}
	}()
	switch {
	case _f.IP < 2:
		SquareGenerator(n)
		_f.IP = 2
		fallthrough
	case _f.IP < 3:
		SquareGenerator(n)
	}
}

func SquareGeneratorTwiceLoop(n int) {
	_c := coroutine.LoadContext[int, any]()
	_f, _fp := _c.Push()
	var _o0 int
	var _o1 bool
	if _f.IP > 0 {
		if _v := _f.Get(0); _v != nil {
			n = _v.(int)
		}
		if _v := _f.Get(1); _v != nil {
			_o0 = _v.(int)
		}
		if _v := _f.Get(2); _v != nil {
			_o1 = _v.(bool)
		}
	}
	defer func() {
		if _c.Unwinding() {
			_f.Set(0, n)
			_f.Set(1, _o0)
			_f.Set(2, _o1)
			_c.Store(_fp, _f)
		} else {
			_c.Pop()
		}
	}()
	switch {
	case _f.IP < 2:
		_o0 = 0
		_f.IP = 2
		fallthrough
	case _f.IP < 5:
	_l0:
		for ; ; _o0, _f.IP = _o0+1, 2 {
			switch {
			case _f.IP < 4:
				switch {
				case _f.IP < 3:
					_o1 = !(_o0 < 2)
					_f.IP = 3
					fallthrough
				case _f.IP < 4:
					if _o1 {
						break _l0
					}
				}
				_f.IP = 4
				fallthrough
			case _f.IP < 5:
				SquareGenerator(n)
			}
		}
	}
}

func EvenSquareGenerator(n int) {
	_c := coroutine.LoadContext[int, any]()
	_f, _fp := _c.Push()
	var _o0 int
	var _o1 bool
	var _o2 int
	var _o3 bool
	if _f.IP > 0 {
		if _v := _f.Get(0); _v != nil {
			n = _v.(int)
		}
		if _v := _f.Get(1); _v != nil {
			_o0 = _v.(int)
		}
		if _v := _f.Get(2); _v != nil {
			_o1 = _v.(bool)
		}
		if _v := _f.Get(3); _v != nil {
			_o2 = _v.(int)
		}
		if _v := _f.Get(4); _v != nil {
			_o3 = _v.(bool)
		}
	}
	defer func() {
		if _c.Unwinding() {
			_f.Set(0, n)
			_f.Set(1, _o0)
			_f.Set(2, _o1)
			_f.Set(3, _o2)
			_f.Set(4, _o3)
			_c.Store(_fp, _f)
		} else {
			_c.Pop()
		}
	}()
	switch {
	case _f.IP < 2:
		_o0 = 1
		_f.IP = 2
		fallthrough
	case _f.IP < 7:
	_l0:
		for ; ; _o0, _f.IP = _o0+1, 2 {
			switch {
			case _f.IP < 4:
				switch {
				case _f.IP < 3:
					_o1 = !(_o0 <= n)
					_f.IP = 3
					fallthrough
				case _f.IP < 4:
					if _o1 {
						break _l0
					}
				}
				_f.IP = 4
				fallthrough
			case _f.IP < 7:
				switch {
				case _f.IP < 5:
					_o2 = _o0 % 2
					_f.IP = 5
					fallthrough
				case _f.IP < 6:
					_o3 = _o2 == 0
					_f.IP = 6
					fallthrough
				case _f.IP < 7:
					if _o3 {
						coroutine.Yield[int, any](_o0 * _o0)
					}
				}
			}
		}
	}
}

func NestedLoops(n int) {
	_c := coroutine.LoadContext[int, any]()
	_f, _fp := _c.Push()
	var _o0 int
	var _o1 bool
	var _o2 int
	var _o3 bool
	var _o4 int
	var _o5 bool
	if _f.IP > 0 {
		if _v := _f.Get(0); _v != nil {
			n = _v.(int)
		}
		if _v := _f.Get(1); _v != nil {
			_o0 = _v.(int)
		}
		if _v := _f.Get(2); _v != nil {
			_o1 = _v.(bool)
		}
		if _v := _f.Get(3); _v != nil {
			_o2 = _v.(int)
		}
		if _v := _f.Get(4); _v != nil {
			_o3 = _v.(bool)
		}
		if _v := _f.Get(5); _v != nil {
			_o4 = _v.(int)
		}
		if _v := _f.Get(6); _v != nil {
			_o5 = _v.(bool)
		}
	}
	defer func() {
		if _c.Unwinding() {
			_f.Set(0, n)
			_f.Set(1, _o0)
			_f.Set(2, _o1)
			_f.Set(3, _o2)
			_f.Set(4, _o3)
			_f.Set(5, _o4)
			_f.Set(6, _o5)
			_c.Store(_fp, _f)
		} else {
			_c.Pop()
		}
	}()
	switch {
	case _f.IP < 2:
		_o0 = 1
		_f.IP = 2
		fallthrough
	case _f.IP < 11:
	_l0:
		for ; ; _o0, _f.IP = _o0+1, 2 {
			switch {
			case _f.IP < 4:
				switch {
				case _f.IP < 3:
					_o1 = !(_o0 <= n)
					_f.IP = 3
					fallthrough
				case _f.IP < 4:
					if _o1 {
						break _l0
					}
				}
				_f.IP = 4
				fallthrough
			case _f.IP < 11:
				switch {
				case _f.IP < 5:
					_o2 = 1
					_f.IP = 5
					fallthrough
				case _f.IP < 11:
				_l1:
					for ; ; _o2, _f.IP = _o2+1, 5 {
						switch {
						case _f.IP < 7:
							switch {
							case _f.IP < 6:
								_o3 = !(_o2 <= n)
								_f.IP = 6
								fallthrough
							case _f.IP < 7:
								if _o3 {
									break _l1
								}
							}
							_f.IP = 7
							fallthrough
						case _f.IP < 11:
							switch {
							case _f.IP < 8:
								_o4 = 1
								_f.IP = 8
								fallthrough
							case _f.IP < 11:
							_l2:
								for ; ; _o4, _f.IP = _o4+1, 8 {
									switch {
									case _f.IP < 10:
										switch {
										case _f.IP < 9:
											_o5 = !(_o4 <= n)
											_f.IP = 9
											fallthrough
										case _f.IP < 10:
											if _o5 {
												break _l2
											}
										}
										_f.IP = 10
										fallthrough
									case _f.IP < 11:
										coroutine.Yield[int, any](_o0 * _o2 * _o4)
									}
								}
							}
						}
					}
				}
			}
		}
	}
}

func FizzBuzzIfGenerator(n int) {
	_c := coroutine.LoadContext[int, any]()
	_f, _fp := _c.Push()
	var _o0 int
	var _o1 bool
	var _o2 bool
	var _o3 bool
	var _o4 int
	var _o5 bool
	if _f.IP > 0 {
		if _v := _f.Get(0); _v != nil {
			n = _v.(int)
		}
		if _v := _f.Get(1); _v != nil {
			_o0 = _v.(int)
		}
		if _v := _f.Get(2); _v != nil {
			_o1 = _v.(bool)
		}
		if _v := _f.Get(3); _v != nil {
			_o2 = _v.(bool)
		}
		if _v := _f.Get(4); _v != nil {
			_o3 = _v.(bool)
		}
		if _v := _f.Get(5); _v != nil {

			_o4 = _v.(int)
		}
		if _v := _f.Get(6); _v != nil {
			_o5 = _v.(bool)
		}
	}
	defer func() {
		if _c.Unwinding() {
			_f.Set(0, n)
			_f.Set(1, _o0)
			_f.Set(2, _o1)
			_f.Set(3, _o2)
			_f.Set(4, _o3)
			_f.Set(5, _o4)
			_f.Set(6, _o5)
			_c.Store(_fp, _f)
		} else {
			_c.Pop()
		}
	}()
	switch {
	case _f.IP < 2:
		_o0 = 1
		_f.IP = 2
		fallthrough
	case _f.IP < 12:
	_l0:
		for ; ; _o0, _f.IP = _o0+1, 2 {
			switch {
			case _f.IP < 4:
				switch {
				case _f.IP < 3:
					_o1 = !(_o0 <= n)
					_f.IP = 3
					fallthrough
				case _f.IP < 4:
					if _o1 {
						break _l0
					}
				}
				_f.IP = 4
				fallthrough
			case _f.IP < 12:
				switch {
				case _f.IP < 5:
					_o2 = _o0%3 == 0 && _o0%5 == 0
					_f.IP = 5
					fallthrough
				case _f.IP < 12:
					if _o2 {
						coroutine.Yield[int, any](FizzBuzz)
					} else {
						_o3 = _o0%3 == 0
						if _o3 {
							coroutine.Yield[int, any](Fizz)
						} else {
							_o4 = _o0 % 5
							_o5 = _o4 == 0
							if _o5 {
								coroutine.Yield[int, any](Buzz)
							} else {

								coroutine.Yield[int, any](_o0)
							}
						}
					}
				}
			}
		}
	}
}

func FizzBuzzSwitchGenerator(n int) {
	_c := coroutine.LoadContext[int, any]()
	_f, _fp := _c.Push()
	var _o0 int
	var _o1 bool
	var _o2 bool
	var _o3 bool
	var _o4 bool
	if _f.IP > 0 {
		if _v := _f.Get(0); _v != nil {
			n = _v.(int)
		}
		if _v := _f.Get(1); _v != nil {
			_o0 = _v.(int)
		}
		if _v := _f.Get(2); _v != nil {
			_o1 = _v.(bool)
		}
		if _v := _f.Get(3); _v != nil {
			_o2 = _v.(bool)
		}
		if _v := _f.Get(4); _v != nil {
			_o3 = _v.(bool)
		}
		if _v := _f.Get(5); _v != nil {
			_o4 = _v.(bool)
		}
	}
	defer func() {
		if _c.Unwinding() {
			_f.Set(0, n)
			_f.Set(1, _o0)
			_f.Set(2, _o1)
			_f.Set(3, _o2)
			_f.Set(4, _o3)
			_f.Set(5, _o4)
			_c.Store(_fp, _f)
		} else {
			_c.Pop()
		}
	}()
	switch {
	case _f.IP < 2:
		_o0 = 1
		_f.IP = 2
		fallthrough
	case _f.IP < 11:
	_l0:
		for ; ; _o0, _f.IP = _o0+1, 2 {
			switch {
			case _f.IP < 4:
				switch {
				case _f.IP < 3:
					_o1 = !(_o0 <= n)
					_f.IP = 3
					fallthrough
				case _f.IP < 4:
					if _o1 {
						break _l0
					}
				}
				_f.IP = 4
				fallthrough
			case _f.IP < 11:
				switch {
				default:
					switch {
					case _f.IP < 5:
						_o2 = _o0%3 == 0 && _o0%5 == 0
						_f.IP = 5
						fallthrough
					case _f.IP < 11:
						if _o2 {
							coroutine.Yield[int, any](FizzBuzz)
						} else {
							_o3 = _o0%3 == 0
							if _o3 {
								coroutine.Yield[int, any](Fizz)
							} else {
								_o4 = _o0%5 == 0
								if _o4 {
									coroutine.Yield[int, any](Buzz)
								} else {

									coroutine.Yield[int, any](_o0)
								}
							}
						}
					}
				}
			}
		}
	}
}

func Shadowing(_ int) {
	_c := coroutine.LoadContext[int, any]()
	_f, _fp := _c.Push()
	var _o0 int
	var _o1 int
	var _o2 int
	var _o3 bool
	var _o4 int
	var _o5 int
	var _o6 bool
	var _o7 int
	var _o8 int
	var _o9 int
	var _o10 int
	var _o11 int
	var _o12 int

	const _o13 = 11

	const _o14 = 12
	var _o15 int

	type _o16 uint16

	type _o17 uint32

	const _o18 = 1
	type _o19 [_o18]uint8

	type _o20 [_o18]uint8

	const _o21 = unsafe.Sizeof(_o20{}) * 2
	type _o22 [_o21]uint8
	if _f.IP > 0 {
		if _v := _f.Get(0); _v != nil {
			_o0 = _v.(int)
		}
		if _v := _f.Get(1); _v != nil {

			_o1 = _v.(int)
		}
		if _v := _f.Get(2); _v != nil {

			_o2 = _v.(int)
		}
		if _v := _f.Get(3); _v != nil {
			_o3 = _v.(bool)
		}
		if _v := _f.Get(4); _v != nil {

			_o4 = _v.(int)
		}
		if _v := _f.Get(5); _v != nil {
			_o5 = _v.(int)
		}
		if _v := _f.Get(6); _v != nil {
			_o6 = _v.(bool)
		}
		if _v := _f.Get(7); _v != nil {

			_o7 = _v.(int)
		}
		if _v := _f.Get(8); _v != nil {
			_o8 = _v.(int)
		}
		if _v := _f.Get(9); _v != nil {

			_o9 = _v.(int)
		}
		if _v := _f.Get(10); _v != nil {

			_o10 = _v.(int)
		}
		if _v := _f.Get(11); _v != nil {

			_o11 = _v.(int)
		}
		if _v := _f.Get(12); _v != nil {

			_o12 = _v.(int)
		}
		if _v := _f.Get(13); _v != nil {

			_o15 = _v.(int)
		}
	}
	defer func() {
		if _c.Unwinding() {
			_f.Set(0, _o0)
			_f.Set(1, _o1)
			_f.Set(2, _o2)
			_f.Set(3, _o3)
			_f.Set(4, _o4)
			_f.Set(5, _o5)
			_f.Set(6, _o6)
			_f.Set(7, _o7)
			_f.Set(8, _o8)
			_f.Set(9, _o9)
			_f.Set(10, _o10)
			_f.Set(11, _o11)
			_f.Set(12, _o12)
			_f.Set(13, _o15)
			_c.Store(_fp, _f)
		} else {
			_c.Pop()
		}
	}()
	switch {
	case _f.IP < 2:
		_o0 = 0
		_f.IP = 2
		fallthrough
	case _f.IP < 3:
		coroutine.Yield[int, any](_o0)
		_f.IP = 3
		fallthrough
	case _f.IP < 5:
		switch {
		case _f.IP < 4:

			_o1 = 1
			_f.IP = 4
			fallthrough
		case _f.IP < 5:
			if true {
				coroutine.Yield[int, any](_o1)
			}
		}
		_f.IP = 5
		fallthrough
	case _f.IP < 6:

		coroutine.Yield[int, any](_o0)
		_f.IP = 6
		fallthrough
	case _f.IP < 10:
		switch {
		case _f.IP < 7:

			_o2 = 1
			_f.IP = 7
			fallthrough
		case _f.IP < 10:
		_l0:
			for ; ; _o2, _f.IP = _o2+1, 7 {
				switch {
				case _f.IP < 9:
					switch {
					case _f.IP < 8:
						_o3 = !(_o2 < 3)
						_f.IP = 8
						fallthrough
					case _f.IP < 9:
						if _o3 {
							break _l0
						}
					}
					_f.IP = 9
					fallthrough
				case _f.IP < 10:
					coroutine.Yield[int, any](_o2)
				}
			}
		}
		_f.IP = 10
		fallthrough
	case _f.IP < 11:

		coroutine.Yield[int, any](_o0)
		_f.IP = 11
		fallthrough
	case _f.IP < 18:
		switch {
		case _f.IP < 12:

			_o4 = 1
			_f.IP = 12
			fallthrough
		case _f.IP < 13:
			_o5 = _o4
			_f.IP = 13
			fallthrough
		case _f.IP < 18:
			switch {
			default:
				switch {
				case _f.IP < 14:
					_o6 = _o5 ==
						1
					_f.IP = 14
					fallthrough
				case _f.IP < 18:
					if _o6 {
						switch {
						case _f.IP < 17:
							switch {
							case _f.IP < 15:
								_o7 = 2
								_f.IP = 15
								fallthrough
							case _f.IP < 16:
								_o8 = _o7
								_f.IP = 16
								fallthrough
							case _f.IP < 17:
								switch {
								default:

									coroutine.Yield[int, any](_o7)
								}
							}
							_f.IP = 17
							fallthrough
						case _f.IP < 18:

							coroutine.Yield[int, any](_o4)
						}
					}
				}
			}
		}
		_f.IP = 18
		fallthrough
	case _f.IP < 19:

		coroutine.Yield[int, any](_o0)
		_f.IP = 19
		fallthrough
	case _f.IP < 23:
		switch {
		case _f.IP < 20:

			_o9 = 1
			_f.IP = 20
			fallthrough
		case _f.IP < 22:
			switch {
			case _f.IP < 21:

				_o10 = 2
				_f.IP = 21
				fallthrough
			case _f.IP < 22:
				coroutine.Yield[int, any](_o10)
			}
			_f.IP = 22
			fallthrough
		case _f.IP < 23:

			coroutine.Yield[int, any](_o9)
		}
		_f.IP = 23
		fallthrough
	case _f.IP < 24:

		coroutine.Yield[int, any](_o0)
		_f.IP = 24
		fallthrough
	case _f.IP < 25:
		_o11 = _o0
		_f.IP = 25
		fallthrough
	case _f.IP < 27:
		switch {
		case _f.IP < 26:

			_o12 = 1
			_f.IP = 26
			fallthrough
		case _f.IP < 27:
			coroutine.Yield[int, any](_o12)
		}
		_f.IP = 27
		fallthrough
	case _f.IP < 28:

		coroutine.Yield[int, any](_o11)
		_f.IP = 28
		fallthrough
	case _f.IP < 31:
		switch {
		case _f.IP < 30:
			switch {
			case _f.IP < 29:

				_o15 = 13
				_f.IP = 29
				fallthrough
			case _f.IP < 30:
				coroutine.Yield[int, any](_o15)
			}
			_f.IP = 30
			fallthrough
		case _f.IP < 31:

			coroutine.Yield[int, any](_o14)
		}
		_f.IP = 31
		fallthrough
	case _f.IP < 32:

		coroutine.Yield[int, any](_o13)
		_f.IP = 32
		fallthrough
	case _f.IP < 33:

		coroutine.Yield[int, any](int(unsafe.Sizeof(_o17(0))))
		_f.IP = 33
		fallthrough
	case _f.IP < 34:

		coroutine.Yield[int, any](int(unsafe.Sizeof(_o16(0))))
		_f.IP = 34
		fallthrough
	case _f.IP < 36:
		switch {
		case _f.IP < 35:

			coroutine.Yield[int, any](int(unsafe.Sizeof(_o20{})))
			_f.IP = 35
			fallthrough
		case _f.IP < 36:

			coroutine.Yield[int, any](int(unsafe.Sizeof(_o22{})))
		}
		_f.IP = 36
		fallthrough
	case _f.IP < 37:

		coroutine.Yield[int, any](int(unsafe.Sizeof(_o19{})))
	}
}

func RangeSliceIndexGenerator(_ int) {
	_c := coroutine.LoadContext[int, any]()
	_f, _fp := _c.Push()
	var _o0 []int
	var _o1 int
	var _o2 bool
	if _f.IP > 0 {
		if _v := _f.Get(0); _v != nil {
			_o0 = _v.([]int)
		}
		if _v := _f.Get(1); _v != nil {
			_o1 = _v.(int)
		}
		if _v := _f.Get(2); _v != nil {
			_o2 = _v.(bool)
		}
	}
	defer func() {
		if _c.Unwinding() {
			_f.Set(0, _o0)
			_f.Set(1, _o1)
			_f.Set(2, _o2)
			_c.Store(_fp, _f)
		} else {
			_c.Pop()
		}
	}()
	switch {
	case _f.IP < 2:
		_o0 = []int{10, 20, 30}
		_f.IP = 2
		fallthrough
	case _f.IP < 6:
		switch {
		case _f.IP < 3:
			_o1 = 0
			_f.IP = 3
			fallthrough
		case _f.IP < 6:
		_l0:
			for ; ; _o1, _f.IP = _o1+1, 3 {
				switch {
				case _f.IP < 5:
					switch {
					case _f.IP < 4:
						_o2 = !(_o1 < len(_o0))
						_f.IP = 4
						fallthrough
					case _f.IP < 5:
						if _o2 {
							break _l0
						}
					}
					_f.IP = 5
					fallthrough
				case _f.IP < 6:
					coroutine.Yield[int, any](_o1)
				}
			}
		}
	}
}

func RangeArrayIndexValueGenerator(_ int) {
	_c := coroutine.LoadContext[int, any]()
	_f, _fp := _c.Push()
	var _o0 [3]int
	var _o1 int
	var _o2 bool
	var _o3 int
	if _f.IP > 0 {
		if _v := _f.Get(0); _v != nil {
			_o0 = _v.([3]int)
		}
		if _v := _f.Get(1); _v != nil {
			_o1 = _v.(int)
		}
		if _v := _f.Get(2); _v != nil {
			_o2 = _v.(bool)
		}
		if _v := _f.Get(3); _v != nil {
			_o3 = _v.(int)
		}
	}
	defer func() {
		if _c.Unwinding() {
			_f.Set(0, _o0)
			_f.Set(1, _o1)
			_f.Set(2, _o2)
			_f.Set(3, _o3)
			_c.Store(_fp, _f)
		} else {
			_c.Pop()
		}
	}()
	switch {
	case _f.IP < 2:
		_o0 = [...]int{10, 20, 30}
		_f.IP = 2
		fallthrough
	case _f.IP < 8:
		switch {
		case _f.IP < 3:
			_o1 = 0
			_f.IP = 3
			fallthrough
		case _f.IP < 8:
		_l0:
			for ; ; _o1, _f.IP = _o1+1, 3 {
				switch {
				case _f.IP < 5:
					switch {
					case _f.IP < 4:
						_o2 = !(_o1 < len(_o0))
						_f.IP = 4
						fallthrough
					case _f.IP < 5:
						if _o2 {
							break _l0
						}
					}
					_f.IP = 5
					fallthrough
				case _f.IP < 6:
					_o3 = _o0[_o1]
					_f.IP = 6
					fallthrough
				case _f.IP < 7:
					coroutine.Yield[int, any](_o1)
					_f.IP = 7
					fallthrough
				case _f.IP < 8:
					coroutine.Yield[int, any](_o3)
				}
			}
		}
	}
}

func TypeSwitchingGenerator(_ int) {
	_c := coroutine.LoadContext[int, any]()
	_f, _fp := _c.Push()
	var _o0 []any
	var _o1 int
	var _o2 bool
	var _o3 any
	var _o4 any
	var _o5 any
	if _f.IP > 0 {
		if _v := _f.Get(0); _v != nil {
			_o0 = _v.([]any)
		}
		if _v := _f.Get(1); _v != nil {
			_o1 = _v.(int)
		}
		if _v := _f.Get(2); _v != nil {
			_o2 = _v.(bool)
		}
		if _v := _f.Get(3); _v != nil {
			_o3 = _v.(any)
		}
		if _v := _f.Get(4); _v != nil {
			_o4 = _v.(any)
		}
		if _v := _f.Get(5); _v != nil {
			_o5 = _v.(any)
		}
	}
	defer func() {
		if _c.Unwinding() {
			_f.Set(0, _o0)
			_f.Set(1, _o1)
			_f.Set(2, _o2)
			_f.Set(3, _o3)
			_f.Set(4, _o4)
			_f.Set(5, _o5)
			_c.Store(_fp, _f)
		} else {
			_c.Pop()
		}
	}()
	switch {
	case _f.IP < 2:
		_o0 = []any{int8(10), int16(20), int32(30), int64(40)}
		_f.IP = 2
		fallthrough
	case _f.IP < 16:
		switch {
		case _f.IP < 3:
			_o1 = 0
			_f.IP = 3
			fallthrough
		case _f.IP < 16:
		_l0:
			for ; ; _o1, _f.IP = _o1+1, 3 {
				switch {
				case _f.IP < 5:
					switch {
					case _f.IP < 4:
						_o2 = !(_o1 < len(_o0))
						_f.IP = 4
						fallthrough
					case _f.IP < 5:
						if _o2 {
							break _l0
						}
					}
					_f.IP = 5
					fallthrough
				case _f.IP < 6:
					_o3 = _o0[_o1]
					_f.IP = 6
					fallthrough
				case _f.IP < 11:
					switch {
					case _f.IP < 7:
						_o4 = _o3
						_f.IP = 7
						fallthrough
					case _f.IP < 11:
						switch _o4.(type) {
						case int8:
							coroutine.Yield[int, any](1)
						case int16:
							coroutine.Yield[int, any](2)
						case int32:
							coroutine.Yield[int, any](4)
						case int64:
							coroutine.Yield[int, any](8)
						}
					}
					_f.IP = 11
					fallthrough
				case _f.IP < 16:
					switch {
					case _f.IP < 12:
						_o5 = _o3
						_f.IP = 12
						fallthrough
					case _f.IP < 16:
						switch v := _o5.(type) {
						case int8:
							coroutine.Yield[int, any](int(v))
						case int16:
							coroutine.Yield[int, any](int(v))
						case int32:
							coroutine.Yield[int, any](int(v))
						case int64:
							coroutine.Yield[int, any](int(v))
						}
					}
				}
			}
		}
	}
}

func LoopBreakAndContinue(_ int) {
	_c := coroutine.LoadContext[int, any]()
	_f, _fp := _c.Push()
	var _o0 int
	var _o1 bool
	var _o2 int
	var _o3 bool
	var _o4 bool
	var _o5 int
	var _o6 bool
	var _o7 int
	var _o8 bool
	var _o9 int
	var _o10 bool
	var _o11 bool
	var _o12 int
	var _o13 bool
	var _o14 bool
	if _f.IP > 0 {
		if _v := _f.Get(0); _v != nil {
			_o0 = _v.(int)
		}
		if _v := _f.Get(1); _v != nil {
			_o1 = _v.(bool)
		}
		if _v := _f.Get(2); _v != nil {
			_o2 = _v.(int)
		}
		if _v := _f.Get(3); _v != nil {
			_o3 = _v.(bool)
		}
		if _v := _f.Get(4); _v != nil {
			_o4 = _v.(bool)
		}
		if _v := _f.Get(5); _v != nil {

			_o5 = _v.(int)
		}
		if _v := _f.Get(6); _v != nil {
			_o6 = _v.(bool)
		}
		if _v := _f.Get(7); _v != nil {
			_o7 = _v.(int)
		}
		if _v := _f.Get(8); _v != nil {
			_o8 = _v.(bool)
		}
		if _v := _f.Get(9); _v != nil {
			_o9 = _v.(int)
		}
		if _v := _f.Get(10); _v != nil {
			_o10 = _v.(bool)
		}
		if _v := _f.Get(11); _v != nil {
			_o11 = _v.(bool)
		}
		if _v := _f.Get(12); _v != nil {
			_o12 = _v.(int)
		}
		if _v := _f.Get(13); _v != nil {
			_o13 = _v.(bool)
		}
		if _v := _f.Get(14); _v != nil {
			_o14 = _v.(bool)
		}
	}
	defer func() {
		if _c.Unwinding() {
			_f.Set(0, _o0)
			_f.Set(1, _o1)
			_f.Set(2, _o2)
			_f.Set(3, _o3)
			_f.Set(4, _o4)
			_f.Set(5, _o5)
			_f.Set(6, _o6)
			_f.Set(7, _o7)
			_f.Set(8, _o8)
			_f.Set(9, _o9)
			_f.Set(10, _o10)
			_f.Set(11, _o11)
			_f.Set(12, _o12)
			_f.Set(13, _o13)
			_f.Set(14, _o14)
			_c.Store(_fp, _f)
		} else {
			_c.Pop()
		}
	}()
	switch {
	case _f.IP < 10:
		switch {
		case _f.IP < 2:
			_o0 = 0
			_f.IP = 2
			fallthrough
		case _f.IP < 10:
		_l0:
			for ; ; _o0, _f.IP = _o0+1, 2 {
				switch {
				case _f.IP < 4:
					switch {
					case _f.IP < 3:
						_o1 = !(_o0 < 10)
						_f.IP = 3
						fallthrough
					case _f.IP < 4:
						if _o1 {
							break _l0
						}
					}
					_f.IP = 4
					fallthrough
				case _f.IP < 7:
					switch {
					case _f.IP < 5:
						_o2 = _o0 % 2
						_f.IP = 5
						fallthrough
					case _f.IP < 6:
						_o3 = _o2 == 0
						_f.IP = 6
						fallthrough
					case _f.IP < 7:
						if _o3 {
							continue _l0
						}
					}
					_f.IP = 7
					fallthrough
				case _f.IP < 9:
					switch {
					case _f.IP < 8:
						_o4 = _o0 > 5
						_f.IP = 8
						fallthrough
					case _f.IP < 9:
						if _o4 {
							break _l0
						}
					}
					_f.IP = 9
					fallthrough
				case _f.IP < 10:

					coroutine.Yield[int, any](_o0)
				}
			}
		}
		_f.IP = 10
		fallthrough
	case _f.IP < 26:
		switch {
		case _f.IP < 11:

			_o5 = 0
			_f.IP = 11
			fallthrough
		case _f.IP < 26:
		_l1:
			for ; ; _o5, _f.IP = _o5+1, 11 {
				switch {
				case _f.IP < 13:
					switch {
					case _f.IP < 12:
						_o6 = !(_o5 < 2)
						_f.IP = 12
						fallthrough
					case _f.IP < 13:
						if _o6 {
							break _l1
						}
					}
					_f.IP = 13
					fallthrough
				case _f.IP < 26:
					switch {
					case _f.IP < 14:
						_o7 = 0
						_f.IP = 14
						fallthrough
					case _f.IP < 26:
					_l2:
						for ; ; _o7, _f.IP = _o7+1, 14 {
							switch {
							case _f.IP < 16:
								switch {
								case _f.IP < 15:
									_o8 = !(_o7 < 3)
									_f.IP = 15
									fallthrough
								case _f.IP < 16:
									if _o8 {
										break _l2
									}
								}
								_f.IP = 16
								fallthrough
							case _f.IP < 17:
								coroutine.Yield[int, any](_o7)
								_f.IP = 17
								fallthrough
							case _f.IP < 26:
								switch {
								case _f.IP < 18:
									_o9 = _o7
									_f.IP = 18
									fallthrough
								case _f.IP < 26:
									switch {
									default:
										switch {
										case _f.IP < 19:
											_o10 = _o9 ==
												0
											_f.IP = 19
											fallthrough
										case _f.IP < 26:
											if _o10 {
												continue _l2
											} else {
												_o11 = _o9 ==

													1
												if _o11 {
													{
														_o12 = _o5
														switch {
														default:
															{
																_o13 = _o12 ==
																	0
																if _o13 {
																	continue _l1
																} else {
																	_o14 = _o12 ==

																		1
																	if _o14 {
																		break _l1
																	}
																}
															}
														}
													}
												}
											}
										}
									}
								}
							}
						}
					}
				}
			}
		}
	}
}

func RangeOverMaps(n int) {
	_c := coroutine.LoadContext[int, any]()
	_f, _fp := _c.Push()
	var _o0 map[int]int
	var _o1 map[int]int
	var _o2 int
	var _o3 bool
	var _o4 map[int]int
	var _o5 int
	var _o6 bool
	var _o7 map[int]int
	var _o8 int
	var _o9 bool
	var _o10 map[int]int
	var _o11 int
	var _o12 bool
	var _o13 map[int]int
	var _o14 []int
	var _o15 []int
	var _o16 int
	var _o17 bool
	var _o18 int
	var _o19 bool
	var _o20 map[int]int
	var _o21 []int
	var _o22 []int
	var _o23 int
	var _o24 bool
	var _o25 int
	var _o26 int
	var _o27 bool
	var _o28 map[int]struct {
	}
	var _o29 int
	var _o30 bool
	var _o31 map[int]struct {
	}
	var _o32 []int
	var _o33 []int
	var _o34 int
	var _o35 bool
	var _o36 int
	var _o37 bool
	if _f.IP > 0 {
		if _v := _f.Get(0); _v != nil {
			n = _v.(int)
		}
		if _v := _f.Get(1); _v != nil {
			_o0 = _v.(map[int]int)
		}
		if _v := _f.Get(2); _v != nil {
			_o1 = _v.(map[int]int)
		}
		if _v := _f.Get(3); _v != nil {
			_o2 = _v.(int)
		}
		if _v := _f.Get(4); _v != nil {
			_o3 = _v.(bool)
		}
		if _v := _f.Get(5); _v != nil {
			_o4 = _v.(map[int]int)
		}
		if _v := _f.Get(6); _v != nil {
			_o5 = _v.(int)
		}
		if _v := _f.Get(7); _v != nil {
			_o6 = _v.(bool)
		}
		if _v := _f.Get(8); _v != nil {
			_o7 = _v.(map[int]int)
		}
		if _v := _f.Get(9); _v != nil {
			_o8 = _v.(int)
		}
		if _v := _f.Get(10); _v != nil {
			_o9 = _v.(bool)
		}
		if _v := _f.Get(11); _v != nil {
			_o10 = _v.(map[int]int)
		}
		if _v := _f.Get(12); _v != nil {
			_o11 = _v.(int)
		}
		if _v := _f.Get(13); _v != nil {
			_o12 = _v.(bool)
		}
		if _v := _f.Get(14); _v != nil {
			_o13 = _v.(map[int]int)
		}
		if _v := _f.Get(15); _v != nil {
			_o14 = _v.([]int)
		}
		if _v := _f.Get(16); _v != nil {
			_o15 = _v.([]int)
		}
		if _v := _f.Get(17); _v != nil {
			_o16 = _v.(int)
		}
		if _v := _f.Get(18); _v != nil {
			_o17 = _v.(bool)
		}
		if _v := _f.Get(19); _v != nil {

			_o18 = _v.(int)
		}
		if _v := _f.Get(20); _v != nil {
			_o19 = _v.(bool)
		}
		if _v := _f.Get(21); _v != nil {
			_o20 = _v.(map[int]int)
		}
		if _v := _f.Get(22); _v != nil {
			_o21 = _v.([]int)
		}
		if _v := _f.Get(23); _v != nil {
			_o22 = _v.([]int)
		}
		if _v := _f.Get(24); _v != nil {
			_o23 = _v.(int)
		}
		if _v := _f.Get(25); _v != nil {
			_o24 = _v.(bool)
		}
		if _v := _f.Get(26); _v != nil {

			_o25 = _v.(int)
		}
		if _v := _f.Get(27); _v != nil {
			_o26 = _v.(int)
		}
		if _v := _f.Get(28); _v != nil {
			_o27 = _v.(bool)
		}
		if _v := _f.Get(29); _v != nil {

			_o28 = _v.(map[int]struct {
			})
		}
		if _v := _f.Get(30); _v != nil {
			_o29 = _v.(int)
		}
		if _v := _f.Get(31); _v != nil {
			_o30 = _v.(bool)
		}
		if _v := _f.Get(32); _v != nil {
			_o31 = _v.(map[int]struct {
			})
		}
		if _v := _f.Get(33); _v != nil {
			_o32 = _v.([]int)
		}
		if _v := _f.Get(34); _v != nil {
			_o33 = _v.([]int)
		}
		if _v := _f.Get(35); _v != nil {
			_o34 = _v.(int)
		}
		if _v := _f.Get(36); _v != nil {
			_o35 = _v.(bool)
		}
		if _v := _f.Get(37); _v != nil {

			_o36 = _v.(int)
		}
		if _v := _f.Get(38); _v != nil {
			_o37 = _v.(bool)
		}
	}
	defer func() {
		if _c.Unwinding() {
			_f.Set(0, n)
			_f.Set(1, _o0)
			_f.Set(2, _o1)
			_f.Set(3, _o2)
			_f.Set(4, _o3)
			_f.Set(5, _o4)
			_f.Set(6, _o5)
			_f.Set(7, _o6)
			_f.Set(8, _o7)
			_f.Set(9, _o8)
			_f.Set(10, _o9)
			_f.Set(11, _o10)
			_f.Set(12, _o11)
			_f.Set(13, _o12)
			_f.Set(14, _o13)
			_f.Set(15, _o14)
			_f.Set(16, _o15)
			_f.Set(17, _o16)
			_f.Set(18, _o17)
			_f.Set(19, _o18)
			_f.Set(20, _o19)
			_f.Set(21, _o20)
			_f.Set(22, _o21)
			_f.Set(23, _o22)
			_f.Set(24, _o23)
			_f.Set(25, _o24)
			_f.Set(26, _o25)
			_f.Set(27, _o26)
			_f.Set(28, _o27)
			_f.Set(29, _o28)
			_f.Set(30, _o29)
			_f.Set(31, _o30)
			_f.Set(32, _o31)
			_f.Set(33, _o32)
			_f.Set(34, _o33)
			_f.Set(35, _o34)
			_f.Set(36, _o35)
			_f.Set(37, _o36)
			_f.Set(38, _o37)
			_c.Store(_fp, _f)
		} else {
			_c.Pop()
		}
	}()
	switch {
	case _f.IP < 2:
		_o0 = map[int]int{}
		_f.IP = 2
		fallthrough
	case _f.IP < 7:
		switch {
		case _f.IP < 3:
			_o1 = _o0
			_f.IP = 3
			fallthrough
		case _f.IP < 7:
			switch {
			case _f.IP < 4:
				_o2 = 0
				_f.IP = 4
				fallthrough
			case _f.IP < 7:
			_l0:
				for ; ; _o2, _f.IP = _o2+1, 4 {
					switch {
					case _f.IP < 6:
						switch {
						case _f.IP < 5:
							_o3 = !(_o2 < len(_o1))
							_f.IP = 5
							fallthrough
						case _f.IP < 6:
							if _o3 {
								break _l0
							}
						}
						_f.IP = 6
						fallthrough
					case _f.IP < 7:
						panic("unreachable")
					}
				}
			}
		}
		_f.IP = 7
		fallthrough
	case _f.IP < 12:
		switch {
		case _f.IP < 8:
			_o4 = _o0
			_f.IP = 8
			fallthrough
		case _f.IP < 12:
			switch {
			case _f.IP < 9:
				_o5 = 0
				_f.IP = 9
				fallthrough
			case _f.IP < 12:
			_l1:
				for ; ; _o5, _f.IP = _o5+1, 9 {
					switch {
					case _f.IP < 11:
						switch {
						case _f.IP < 10:
							_o6 = !(_o5 < len(_o4))
							_f.IP = 10
							fallthrough
						case _f.IP < 11:
							if _o6 {
								break _l1
							}
						}
						_f.IP = 11
						fallthrough
					case _f.IP < 12:
						panic("unreachable")
					}
				}
			}
		}
		_f.IP = 12
		fallthrough
	case _f.IP < 17:
		switch {
		case _f.IP < 13:
			_o7 = _o0
			_f.IP = 13
			fallthrough
		case _f.IP < 17:
			switch {
			case _f.IP < 14:
				_o8 = 0
				_f.IP = 14
				fallthrough
			case _f.IP < 17:
			_l2:
				for ; ; _o8, _f.IP = _o8+1, 14 {
					switch {
					case _f.IP < 16:
						switch {
						case _f.IP < 15:
							_o9 = !(_o8 < len(_o7))
							_f.IP = 15
							fallthrough
						case _f.IP < 16:
							if _o9 {
								break _l2
							}
						}
						_f.IP = 16
						fallthrough
					case _f.IP < 17:
						panic("unreachable")
					}
				}
			}
		}
		_f.IP = 17
		fallthrough
	case _f.IP < 18:

		_o0[n] = n * 10
		_f.IP = 18
		fallthrough
	case _f.IP < 23:
		switch {
		case _f.IP < 19:
			_o10 = _o0
			_f.IP = 19
			fallthrough
		case _f.IP < 23:
			switch {
			case _f.IP < 20:
				_o11 = 0
				_f.IP = 20
				fallthrough
			case _f.IP < 23:
			_l3:
				for ; ; _o11, _f.IP = _o11+1, 20 {
					switch {
					case _f.IP < 22:
						switch {
						case _f.IP < 21:
							_o12 = !(_o11 < len(_o10))
							_f.IP = 21
							fallthrough
						case _f.IP < 22:
							if _o12 {
								break _l3
							}
						}
						_f.IP = 22
						fallthrough
					case _f.IP < 23:
						coroutine.Yield[int, any](0)
					}
				}
			}
		}
		_f.IP = 23
		fallthrough
	case _f.IP < 33:
		switch {
		case _f.IP < 24:
			_o13 = _o0
			_f.IP = 24
			fallthrough
		case _f.IP < 26:
			switch {
			case _f.IP < 25:
				_o14 = make([]int, 0, len(_o13))
				_f.IP = 25
				fallthrough
			case _f.IP < 26:
				for _v14 := range _o13 {
					_o14 = append(_o14, _v14)
				}
			}
			_f.IP = 26
			fallthrough
		case _f.IP < 33:
			switch {
			case _f.IP < 27:
				_o15 = _o14
				_f.IP = 27
				fallthrough
			case _f.IP < 33:
				switch {
				case _f.IP < 28:
					_o16 = 0
					_f.IP = 28
					fallthrough
				case _f.IP < 33:
				_l4:
					for ; ; _o16, _f.IP = _o16+1, 28 {
						switch {
						case _f.IP < 30:
							switch {
							case _f.IP < 29:
								_o17 = !(_o16 < len(_o15))
								_f.IP = 29
								fallthrough
							case _f.IP < 30:
								if _o17 {
									break _l4
								}
							}
							_f.IP = 30
							fallthrough
						case _f.IP < 31:
							_o18 = _o15[_o16]
							_f.IP = 31
							fallthrough
						case _f.IP < 33:
							switch {
							case _f.IP < 32:
								_, _o19 = _o13[_o18]
								_f.IP = 32
								fallthrough
							case _f.IP < 33:
								if _o19 {
									coroutine.Yield[int, any](_o18)
								}
							}
						}
					}
				}
			}
		}
		_f.IP = 33
		fallthrough
	case _f.IP < 44:
		switch {
		case _f.IP < 34:
			_o20 = _o0
			_f.IP = 34
			fallthrough
		case _f.IP < 36:
			switch {
			case _f.IP < 35:
				_o21 = make([]int, 0, len(_o20))
				_f.IP = 35
				fallthrough
			case _f.IP < 36:
				for _v21 := range _o20 {
					_o21 = append(_o21, _v21)
				}
			}
			_f.IP = 36
			fallthrough
		case _f.IP < 44:
			switch {
			case _f.IP < 37:
				_o22 = _o21
				_f.IP = 37
				fallthrough
			case _f.IP < 44:
				switch {
				case _f.IP < 38:
					_o23 = 0
					_f.IP = 38
					fallthrough
				case _f.IP < 44:
				_l5:
					for ; ; _o23, _f.IP = _o23+1, 38 {
						switch {
						case _f.IP < 40:
							switch {
							case _f.IP < 39:
								_o24 = !(_o23 < len(_o22))
								_f.IP = 39
								fallthrough
							case _f.IP < 40:
								if _o24 {
									break _l5
								}
							}
							_f.IP = 40
							fallthrough
						case _f.IP < 41:
							_o25 = _o22[_o23]
							_f.IP = 41
							fallthrough
						case _f.IP < 44:
							switch {
							case _f.IP < 42:
								_o26, _o27 = _o20[_o25]
								_f.IP = 42
								fallthrough
							case _f.IP < 44:
								if _o27 {
									switch {
									case _f.IP < 43:
										coroutine.Yield[int, any](_o25)
										_f.IP = 43
										fallthrough
									case _f.IP < 44:
										coroutine.Yield[int, any](_o26)
									}
								}
							}
						}
					}
				}
			}
		}
		_f.IP = 44
		fallthrough
	case _f.IP < 45:

		_o28 = make(map[int]struct{}, n)
		_f.IP = 45
		fallthrough
	case _f.IP < 49:
		switch {
		case _f.IP < 46:
			_o29 = 0
			_f.IP = 46
			fallthrough
		case _f.IP < 49:
		_l6:
			for ; ; _o29, _f.IP = _o29+1, 46 {
				switch {
				case _f.IP < 48:
					switch {
					case _f.IP < 47:
						_o30 = !(_o29 < n)
						_f.IP = 47
						fallthrough
					case _f.IP < 48:
						if _o30 {
							break _l6
						}
					}
					_f.IP = 48
					fallthrough
				case _f.IP < 49:
					_o28[_o29] = struct{}{}
				}
			}
		}
		_f.IP = 49
		fallthrough
	case _f.IP < 50:

		coroutine.Yield[int, any](len(_o28))
		_f.IP = 50
		fallthrough
	case _f.IP < 61:
		switch {
		case _f.IP < 51:
			_o31 = _o28
			_f.IP = 51
			fallthrough
		case _f.IP < 53:
			switch {
			case _f.IP < 52:
				_o32 = make([]int, 0, len(_o31))
				_f.IP = 52
				fallthrough
			case _f.IP < 53:
				for _v29 := range _o31 {
					_o32 = append(_o32, _v29)
				}
			}
			_f.IP = 53
			fallthrough
		case _f.IP < 61:
			switch {
			case _f.IP < 54:
				_o33 = _o32
				_f.IP = 54
				fallthrough
			case _f.IP < 61:
				switch {
				case _f.IP < 55:
					_o34 = 0
					_f.IP = 55
					fallthrough
				case _f.IP < 61:
				_l7:
					for ; ; _o34, _f.IP = _o34+1, 55 {
						switch {
						case _f.IP < 57:
							switch {
							case _f.IP < 56:
								_o35 = !(_o34 < len(_o33))
								_f.IP = 56
								fallthrough
							case _f.IP < 57:
								if _o35 {
									break _l7
								}
							}
							_f.IP = 57
							fallthrough
						case _f.IP < 58:
							_o36 = _o33[_o34]
							_f.IP = 58
							fallthrough
						case _f.IP < 61:
							switch {
							case _f.IP < 59:
								_, _o37 = _o31[_o36]
								_f.IP = 59
								fallthrough
							case _f.IP < 61:
								if _o37 {
									switch {
									case _f.IP < 60:
										delete(_o28, _o36)
										_f.IP = 60
										fallthrough
									case _f.IP < 61:
										coroutine.Yield[int, any](len(_o28))
									}
								}
							}
						}
					}
				}
			}
		}
	}
}

func Range(n int, do func(int)) {
	_c := coroutine.LoadContext[int, any]()
	_f, _fp := _c.Push()
	var _o0 int
	var _o1 bool
	if _f.IP > 0 {
		if _v := _f.Get(0); _v != nil {
			n = _v.(int)
		}
		if _v := _f.Get(1); _v != nil {
			do = _v.(func(int))
		}
		if _v := _f.Get(2); _v != nil {
			_o0 = _v.(int)
		}
		if _v := _f.Get(3); _v != nil {
			_o1 = _v.(bool)
		}
	}
	defer func() {
		if _c.Unwinding() {
			_f.Set(0, n)
			_f.Set(1, do)
			_f.Set(2, _o0)
			_f.Set(3, _o1)
			_c.Store(_fp, _f)
		} else {
			_c.Pop()
		}
	}()
	switch {
	case _f.IP < 2:
		_o0 = 0
		_f.IP = 2
		fallthrough
	case _f.IP < 5:
	_l0:
		for ; ; _o0, _f.IP = _o0+1, 2 {
			switch {
			case _f.IP < 4:
				switch {
				case _f.IP < 3:
					_o1 = !(_o0 < n)
					_f.IP = 3
					fallthrough
				case _f.IP < 4:
					if _o1 {
						break _l0
					}
				}
				_f.IP = 4
				fallthrough
			case _f.IP < 5:
				do(_o0)
			}
		}
	}
}

func Double(n int) {
	_c := coroutine.LoadContext[int, any]()
	_f, _fp := _c.Push()
	if _f.IP > 0 {
		if _v := _f.Get(0); _v != nil {
			n = _v.(int)
		}
	}
	defer func() {
		if _c.Unwinding() {
			_f.Set(0, n)
			_c.Store(_fp, _f)
		} else {
			_c.Pop()
		}
	}()
	coroutine.Yield[int, any](2 * n)
}

func RangeTripleFuncValue(n int) {
	_c := coroutine.LoadContext[int, any]()
	_f, _fp := _c.Push()
	var _o0 func(int)
	if _f.IP > 0 {
		if _v := _f.Get(0); _v != nil {
			n = _v.(int)
		}
		if _v := _f.Get(1); _v != nil {
			_o0 = _v.(func(int))
		}
	}
	defer func() {
		if _c.Unwinding() {
			_f.Set(0, n)
			_f.Set(1, _o0)
			_c.Store(_fp, _f)
		} else {
			_c.Pop()
		}
	}()
	switch {
	case _f.IP < 2:
		_o0 = func(i int) {
			coroutine.Yield[int, any](3 * i)
		}
		_f.IP = 2
		fallthrough
	case _f.IP < 3:
		Range(n, _o0)
	}
}

func Range10ClosureCapturingValues() {
	_c := coroutine.LoadContext[int, any]()
	_f, _fp := _c.Push()
	var _o0 int
	var _o1 int
	var _o2 func() bool
	var _o3 bool
	if _f.IP > 0 {
		if _v := _f.Get(0); _v != nil {
			_o0 = _v.(int)
		}
		if _v := _f.Get(1); _v != nil {
			_o1 = _v.(int)
		}
		if _v := _f.Get(2); _v != nil {
			_o2 = _v.(func() bool)
		}
		if _v := _f.Get(3); _v != nil {
			_o3 = _v.(bool)
		}
	}
	defer func() {
		if _c.Unwinding() {
			_f.Set(0, _o0)
			_f.Set(1, _o1)
			_f.Set(2, _o2)
			_f.Set(3, _o3)
			_c.Store(_fp, _f)
		} else {
			_c.Pop()
		}
	}()
	switch {
	case _f.IP < 2:
		_o0 = 0
		_f.IP = 2
		fallthrough
	case _f.IP < 3:
		_o1 = 10
		_f.IP = 3
		fallthrough
	case _f.IP < 4:
		_o2 = func() bool {
			if _o0 < _o1 {
				coroutine.Yield[int, any](_o0)
				_o0++
				return true
			}
			return false
		}
		_f.IP = 4
		fallthrough
	case _f.IP < 6:
	_l0:
		for ; ; _f.IP = 4 {
			switch {
			case _f.IP < 5:
				_o3 = !_o2()
				_f.IP = 5
				fallthrough
			case _f.IP < 6:
				if _o3 {
					break _l0
				}
			}
		}
	}
}

func Range10ClosureCapturingPointers() {
	_c := coroutine.LoadContext[int, any]()
	_f, _fp := _c.Push()
	var _o0 int
	var _o1 int
	var _o2 *int
	var _o3 *int
	var _o4 func() bool
	if _f.IP > 0 {
		_o0 = _f.Get(0).(int)
		_o1 = _f.Get(1).(int)
		_o2 = _f.Get(2).(*int)
		_o3 = _f.Get(3).(*int)
		_o4 = _f.Get(4).(func() bool)
	}
	defer func() {
		if _c.Unwinding() {
			_f.Set(0, _o0)
			_f.Set(1, _o1)
			_f.Set(2, _o2)
			_f.Set(3, _o3)
			_f.Set(4, _o4)
			_c.Store(_fp, _f)
		} else {
			_c.Pop()
		}
	}()
	switch {
	case _f.IP < 2:
		_o0, _o1 = 0, 10
		_f.IP = 2
		fallthrough
	case _f.IP < 3:
		_o2 = &_o0
		_f.IP = 3
		fallthrough
	case _f.IP < 4:
		_o3 = &_o1
		_f.IP = 4
		fallthrough
	case _f.IP < 5:
		_o4 = func() bool {
			if *_o2 < *_o3 {
				coroutine.Yield[int, any](*_o2)
				(*_o2)++
				return true
			}
			return false
		}
		_f.IP = 5
		fallthrough
	case _f.IP < 6:
		for ; _o4(); _f.IP = 5 {
		}
	}
}

func Range10ClosureHeterogenousCapture() {
	_c := coroutine.LoadContext[int, any]()
	_f, _fp := _c.Push()
	var _o0 int8
	var _o1 int16
	var _o2 int32
	var _o3 int64
	var _o4 uint8
	var _o5 uint16
	var _o6 uint32
	var _o7 uint64
	var _o8 uintptr
	var _o9 int
	var _o10 func() bool
	var _o11 int
	if _f.IP > 0 {
		_o0 = _f.Get(0).(int8)
		_o1 = _f.Get(1).(int16)
		_o2 = _f.Get(2).(int32)
		_o3 = _f.Get(3).(int64)
		_o4 = _f.Get(4).(uint8)
		_o5 = _f.Get(5).(uint16)
		_o6 = _f.Get(6).(uint32)
		_o7 = _f.Get(7).(uint64)
		_o8 = _f.Get(8).(uintptr)

		_o9 = _f.Get(9).(int)
		_o10 = _f.Get(10).(func() bool)
		_o11 = _f.Get(11).(int)
	}
	defer func() {
		if _c.Unwinding() {
			_f.Set(0, _o0)
			_f.Set(1, _o1)
			_f.Set(2, _o2)
			_f.Set(3, _o3)
			_f.Set(4, _o4)
			_f.Set(5, _o5)
			_f.Set(6, _o6)
			_f.Set(7, _o7)
			_f.Set(8, _o8)
			_f.Set(9, _o9)
			_f.Set(10, _o10)
			_f.Set(11, _o11)
			_c.Store(_fp, _f)
		} else {
			_c.Pop()
		}
	}()
	switch {
	case _f.IP < 10:
		switch {
		case _f.IP < 2:
			_o0 = 0
			_f.IP = 2
			fallthrough
		case _f.IP < 3:
			_o1 = 1
			_f.IP = 3
			fallthrough
		case _f.IP < 4:
			_o2 = 2
			_f.IP = 4
			fallthrough
		case _f.IP < 5:
			_o3 = 3
			_f.IP = 5
			fallthrough
		case _f.IP < 6:
			_o4 = 4
			_f.IP = 6
			fallthrough
		case _f.IP < 7:
			_o5 = 5
			_f.IP = 7
			fallthrough
		case _f.IP < 8:
			_o6 = 6
			_f.IP = 8
			fallthrough
		case _f.IP < 9:
			_o7 = 7
			_f.IP = 9
			fallthrough
		case _f.IP < 10:
			_o8 = 8
		}
		_f.IP = 10
		fallthrough
	case _f.IP < 11:

		_o9 = 0
		_f.IP = 11
		fallthrough
	case _f.IP < 12:
		_o10 = func() bool {

			switch _o9 {
			case 0:
				_o11 = int(_o0)
			case 1:
				_o11 = int(_o1)
			case 2:
				_o11 = int(_o2)
			case 3:
				_o11 = int(_o3)
			case 4:
				_o11 = int(_o4)
			case 5:
				_o11 = int(_o5)
			case 6:
				_o11 = int(_o6)
			case 7:
				_o11 = int(_o7)
			case 8:
				_o11 = int(_o8)
			case 9:
				_o11 = int(_o9)
			}
			coroutine.Yield[int, any](_o11)
			_o9++
			return _o9 < 10
		}
		_f.IP = 12
		fallthrough
	case _f.IP < 13:
		for ; _o10(); _f.IP = 12 {
		}
	}
}

func Range10Heterogenous() {
	_c := coroutine.LoadContext[int, any]()
	_f, _fp := _c.Push()
	var _o0 int8
	var _o1 int16
	var _o2 int32
	var _o3 int64
	var _o4 uint8
	var _o5 uint16
	var _o6 uint32
	var _o7 uint64
	var _o8 uintptr
	var _o9 int
	var _o10 int
	if _f.IP > 0 {
		_o0 = _f.Get(0).(int8)
		_o1 = _f.Get(1).(int16)
		_o2 = _f.Get(2).(int32)
		_o3 = _f.Get(3).(int64)
		_o4 = _f.Get(4).(uint8)
		_o5 = _f.Get(5).(uint16)
		_o6 = _f.Get(6).(uint32)
		_o7 = _f.Get(7).(uint64)
		_o8 = _f.Get(8).(uintptr)

		_o9 = _f.Get(9).(int)
		_o10 = _f.Get(10).(int)
	}
	defer func() {
		if _c.Unwinding() {
			_f.Set(0, _o0)
			_f.Set(1, _o1)
			_f.Set(2, _o2)
			_f.Set(3, _o3)
			_f.Set(4, _o4)
			_f.Set(5, _o5)
			_f.Set(6, _o6)
			_f.Set(7, _o7)
			_f.Set(8, _o8)
			_f.Set(9, _o9)
			_f.Set(10, _o10)
			_c.Store(_fp, _f)
		} else {
			_c.Pop()
		}
	}()
	switch {
	case _f.IP < 10:
		switch {
		case _f.IP < 2:
			_o0 = 0
			_f.IP = 2
			fallthrough
		case _f.IP < 3:
			_o1 = 1
			_f.IP = 3
			fallthrough
		case _f.IP < 4:
			_o2 = 2
			_f.IP = 4
			fallthrough
		case _f.IP < 5:
			_o3 = 3
			_f.IP = 5
			fallthrough
		case _f.IP < 6:
			_o4 = 4
			_f.IP = 6
			fallthrough
		case _f.IP < 7:
			_o5 = 5
			_f.IP = 7
			fallthrough
		case _f.IP < 8:
			_o6 = 6
			_f.IP = 8
			fallthrough
		case _f.IP < 9:
			_o7 = 7
			_f.IP = 9
			fallthrough
		case _f.IP < 10:
			_o8 = 8
		}
		_f.IP = 10
		fallthrough
	case _f.IP < 23:
		switch {
		case _f.IP < 11:

			_o9 = 0
			_f.IP = 11
			fallthrough
		case _f.IP < 23:
			for ; _o9 < 10; _o9, _f.IP = _o9+1, 11 {
				switch {
				case _f.IP < 12:
					_f.IP = 12
					fallthrough
				case _f.IP < 22:
					switch _o9 {
					case 0:
						_o10 = int(_o0)
					case 1:
						_o10 = int(_o1)
					case 2:
						_o10 = int(_o2)
					case 3:
						_o10 = int(_o3)
					case 4:
						_o10 = int(_o4)
					case 5:
						_o10 = int(_o5)
					case 6:
						_o10 = int(_o6)
					case 7:
						_o10 = int(_o7)
					case 8:
						_o10 = int(_o8)
					case 9:
						_o10 = int(_o9)
					}
					_f.IP = 22
					fallthrough
				case _f.IP < 23:

					coroutine.Yield[int, any](_o10)
				}
			}
		}
	}
}

func Select(n int) {
	_c := coroutine.LoadContext[int, any]()
	_f, _fp := _c.Push()
	var _o0 int
	var _o1 int
	var _o2 bool
	var _o3 int
	var _o4 bool
	var _o5 int
	var _o6 <-chan time.Time
	var _o7 <-chan time.Time
	var _o8 int
	var _o9 bool
	var _o10 bool
	var _o11 bool
	var _o12 int
	var _o13 <-chan time.Time
	var _o14 int
	var _o15 bool
	var _o16 bool
	var _o17 int
	var _o18 <-chan time.Time
	var _o19 int
	var _o20 bool
	var _o21 int
	var _o22 bool
	if _f.IP > 0 {
		if _v := _f.Get(0); _v != nil {
			n = _v.(int)
		}
		if _v := _f.Get(1); _v != nil {
			_o0 = _v.(int)
		}
		if _v := _f.Get(2); _v != nil {
			_o1 = _v.(int)
		}
		if _v := _f.Get(3); _v != nil {
			_o2 = _v.(bool)
		}
		if _v := _f.Get(4); _v != nil {

			_o3 = _v.(int)
		}
		if _v := _f.Get(5); _v != nil {
			_o4 = _v.(bool)
		}
		if _v := _f.Get(6); _v != nil {
			_o5 = _v.(int)
		}
		if _v := _f.Get(7); _v != nil {
			_o6 = _v.(<-chan time.Time)
		}
		if _v := _f.Get(8); _v != nil {
			_o7 = _v.(<-chan time.Time)
		}
		if _v := _f.Get(9); _v != nil {
			_o8 = _v.(int)
		}
		if _v := _f.Get(10); _v != nil {
			_o9 = _v.(bool)
		}
		if _v := _f.Get(11); _v != nil {
			_o10 = _v.(bool)
		}
		if _v := _f.Get(12); _v != nil {
			_o11 = _v.(bool)
		}
		if _v := _f.Get(13); _v != nil {
			_o12 = _v.(int)
		}
		if _v := _f.Get(14); _v != nil {
			_o13 = _v.(<-chan time.Time)
		}
		if _v := _f.Get(15); _v != nil {
			_o14 = _v.(int)
		}
		if _v := _f.Get(16); _v != nil {
			_o15 = _v.(bool)
		}
		if _v := _f.Get(17); _v != nil {
			_o16 = _v.(bool)
		}
		if _v := _f.Get(18); _v != nil {
			_o17 = _v.(int)
		}
		if _v := _f.Get(19); _v != nil {
			_o18 = _v.(<-chan time.Time)
		}
		if _v := _f.Get(20); _v != nil {
			_o19 = _v.(int)
		}
		if _v := _f.Get(21); _v != nil {
			_o20 = _v.(bool)
		}
		if _v := _f.Get(22); _v != nil {

			_o21 = _v.(int)
		}
		if _v := _f.Get(23); _v != nil {
			_o22 = _v.(bool)
		}
	}
	defer func() {
		if _c.Unwinding() {
			_f.Set(0, n)
			_f.Set(1, _o0)
			_f.Set(2, _o1)
			_f.Set(3, _o2)
			_f.Set(4, _o3)
			_f.Set(5, _o4)
			_f.Set(6, _o5)
			_f.Set(7, _o6)
			_f.Set(8, _o7)
			_f.Set(9, _o8)
			_f.Set(10, _o9)
			_f.Set(11, _o10)
			_f.Set(12, _o11)
			_f.Set(13, _o12)
			_f.Set(14, _o13)
			_f.Set(15, _o14)
			_f.Set(16, _o15)
			_f.Set(17, _o16)
			_f.Set(18, _o17)
			_f.Set(19, _o18)
			_f.Set(20, _o19)
			_f.Set(21, _o20)
			_f.Set(22, _o21)
			_f.Set(23, _o22)
			_c.Store(_fp, _f)
		} else {
			_c.Pop()
		}
	}()
	switch {
	case _f.IP < 6:
		switch {
		case _f.IP < 2:
			_o0 = 0
			_f.IP = 2
			fallthrough
		case _f.IP < 3:
			select {
			default:
				_o0 = 1
			}
			_f.IP = 3
			fallthrough
		case _f.IP < 6:
			switch {
			case _f.IP < 4:
				_o1 = _o0
				_f.IP = 4
				fallthrough
			case _f.IP < 6:
				switch {
				default:
					switch {
					case _f.IP < 5:
						_o2 = _o1 == 1
						_f.IP = 5
						fallthrough
					case _f.IP < 6:
						if _o2 {
							coroutine.Yield[int, any](-1)
						}
					}
				}
			}
		}
		_f.IP = 6
		fallthrough
	case _f.IP < 29:
		switch {
		case _f.IP < 7:

			_o3 = 0
			_f.IP = 7
			fallthrough
		case _f.IP < 29:
		_l1:
			for ; ; _o3, _f.IP = _o3+1, 7 {
				switch {
				case _f.IP < 9:
					switch {
					case _f.IP < 8:
						_o4 = !(_o3 < n)
						_f.IP = 8
						fallthrough
					case _f.IP < 9:
						if _o4 {
							break _l1
						}
					}
					_f.IP = 9
					fallthrough
				case _f.IP < 21:
					switch {
					case _f.IP < 10:
						_o5 = 0
						_f.IP = 10
						fallthrough
					case _f.IP < 11:
						_o6 = time.After(0)
						_f.IP = 11
						fallthrough
					case _f.IP < 12:
						_o7 = time.After(1 * time.Second)
						_f.IP = 12
						fallthrough
					case _f.IP < 14:
						select {
						case <-_o6:
							_o5 = 1
						case <-_o7:
							_o5 = 2
						}
						_f.IP = 14
						fallthrough
					case _f.IP < 21:
						switch {
						case _f.IP < 15:
							_o8 = _o5
							_f.IP = 15
							fallthrough
						case _f.IP < 21:
						_l2:
							switch {
							default:
								switch {
								case _f.IP < 16:
									_o9 = _o8 == 1
									_f.IP = 16
									fallthrough
								case _f.IP < 21:
									if _o9 {
										switch {
										case _f.IP < 18:
											switch {
											case _f.IP < 17:
												_o10 = _o3 >= 5
												_f.IP = 17
												fallthrough
											case _f.IP < 18:
												if _o10 {
													break _l2
												}
											}
											_f.IP = 18
											fallthrough
										case _f.IP < 19:

											coroutine.Yield[int, any](_o3)
										}
									} else {
										_o11 = _o8 == 2
										if _o11 {

											panic("unreachable")
										}
									}
								}
							}
						}
					}
					_f.IP = 21
					fallthrough
				case _f.IP < 29:
					switch {
					case _f.IP < 22:
						_o12 = 0
						_f.IP = 22
						fallthrough
					case _f.IP < 23:
						_o13 = time.After(0)
						_f.IP = 23
						fallthrough
					case _f.IP < 24:
						select {
						case <-_o13:
							_o12 = 1
						}
						_f.IP = 24
						fallthrough
					case _f.IP < 29:
						switch {
						case _f.IP < 25:
							_o14 = _o12
							_f.IP = 25
							fallthrough
						case _f.IP < 29:
						_l3:
							switch {
							default:
								switch {
								case _f.IP < 26:
									_o15 = _o14 == 1
									_f.IP = 26
									fallthrough
								case _f.IP < 29:
									if _o15 {
										switch {
										case _f.IP < 28:
											switch {
											case _f.IP < 27:
												_o16 = _o3 >= 6
												_f.IP = 27
												fallthrough
											case _f.IP < 28:
												if _o16 {
													break _l3
												}
											}
											_f.IP = 28
											fallthrough
										case _f.IP < 29:

											coroutine.Yield[int, any](_o3 * 10)
										}
									}
								}
							}
						}
					}
				}
			}
		}
		_f.IP = 29
		fallthrough
	case _f.IP < 38:
		switch {
		case _f.IP < 30:
			_o17 = 0
			_f.IP = 30
			fallthrough
		case _f.IP < 31:
			_o18 = time.After(0)
			_f.IP = 31
			fallthrough
		case _f.IP < 32:
			select {
			case <-_o18:
				_o17 = 1
			}
			_f.IP = 32
			fallthrough
		case _f.IP < 38:
			switch {
			case _f.IP < 33:
				_o19 = _o17
				_f.IP = 33
				fallthrough
			case _f.IP < 38:
				switch {
				default:
					switch {
					case _f.IP < 34:
						_o20 = _o19 == 1
						_f.IP = 34
						fallthrough
					case _f.IP < 38:
						if _o20 {
							switch {
							case _f.IP < 35:
								_o21 = 0
								_f.IP = 35
								fallthrough
							case _f.IP < 38:
							_l5:
								for ; ; _o21, _f.IP = _o21+1, 35 {
									switch {
									case _f.IP < 37:
										switch {
										case _f.IP < 36:
											_o22 = !(_o21 < 3)
											_f.IP = 36
											fallthrough
										case _f.IP < 37:
											if _o22 {
												break _l5
											}
										}
										_f.IP = 37
										fallthrough
									case _f.IP < 38:
										coroutine.Yield[int, any](_o21)
									}
								}
							}
						}
					}
				}
			}
		}
	}
}
func init() {
	serde.RegisterType[**byte]()
	serde.RegisterType[*[100000]uintptr]()
	serde.RegisterType[*[131072]uint16]()
	serde.RegisterType[*[140737488355327]byte]()
	serde.RegisterType[*[16]byte]()
	serde.RegisterType[*[171]uint8]()
	serde.RegisterType[*[1]uintptr]()
	serde.RegisterType[*[2]byte]()
	serde.RegisterType[*[2]float32]()
	serde.RegisterType[*[2]float64]()
	serde.RegisterType[*[2]int32]()
	serde.RegisterType[*[2]uint32]()
	serde.RegisterType[*[2]uintptr]()
	serde.RegisterType[*[32]rune]()
	serde.RegisterType[*[32]uintptr]()
	serde.RegisterType[*[4]byte]()
	serde.RegisterType[*[512]uintptr]()
	serde.RegisterType[*[65536]uintptr]()
	serde.RegisterType[*[70368744177663]uint16]()
	serde.RegisterType[*[8]byte]()
	serde.RegisterType[*[8]uint8]()
	serde.RegisterType[*[]uint64]()
	serde.RegisterType[*bool]()
	serde.RegisterType[*byte]()
	serde.RegisterType[*int]()
	serde.RegisterType[*int32]()
	serde.RegisterType[*int64]()
	serde.RegisterType[*string]()
	serde.RegisterType[*uint]()
	serde.RegisterType[*uint16]()
	serde.RegisterType[*uint32]()
	serde.RegisterType[*uint64]()
	serde.RegisterType[*uint8]()
	serde.RegisterType[*uintptr]()
	serde.RegisterType[[0]uintptr]()
	serde.RegisterType[[1000]uintptr]()
	serde.RegisterType[[100]byte]()
	serde.RegisterType[[1024]bool]()
	serde.RegisterType[[1024]byte]()
	serde.RegisterType[[1024]int8]()
	serde.RegisterType[[1024]uint8]()
	serde.RegisterType[[1048576]uint8]()
	serde.RegisterType[[104]byte]()
	serde.RegisterType[[104]int8]()
	serde.RegisterType[[107]string]()
	serde.RegisterType[[108]byte]()
	serde.RegisterType[[10]byte]()
	serde.RegisterType[[10]string]()
	serde.RegisterType[[128]byte]()
	serde.RegisterType[[128]uint64]()
	serde.RegisterType[[128]uintptr]()
	serde.RegisterType[[129]uint8]()
	serde.RegisterType[[12]int8]()
	serde.RegisterType[[131072]uintptr]()
	serde.RegisterType[[13]int32]()
	serde.RegisterType[[14]byte]()
	serde.RegisterType[[14]int8]()
	serde.RegisterType[[16384]byte]()
	serde.RegisterType[[16384]uint8]()
	serde.RegisterType[[16]byte]()
	serde.RegisterType[[16]int8]()
	serde.RegisterType[[16]uint64]()
	serde.RegisterType[[16]uintptr]()
	serde.RegisterType[[17]string]()
	serde.RegisterType[[1]byte]()
	serde.RegisterType[[1]uint32]()
	serde.RegisterType[[1]uint64]()
	serde.RegisterType[[1]uint8]()
	serde.RegisterType[[1]uintptr]()
	serde.RegisterType[[20]byte]()
	serde.RegisterType[[20]uint8]()
	serde.RegisterType[[21]byte]()
	serde.RegisterType[[249]uint8]()
	serde.RegisterType[[24]byte]()
	serde.RegisterType[[252]uintptr]()
	serde.RegisterType[[253]uintptr]()
	serde.RegisterType[[256]uint64]()
	serde.RegisterType[[29]uint64]()
	serde.RegisterType[[2]byte]()
	serde.RegisterType[[2]int]()
	serde.RegisterType[[2]int32]()
	serde.RegisterType[[2]int64]()
	serde.RegisterType[[2]uint32]()
	serde.RegisterType[[2]uint64]()
	serde.RegisterType[[2]uintptr]()
	serde.RegisterType[[32]byte]()
	serde.RegisterType[[32]int32]()
	serde.RegisterType[[32]string]()
	serde.RegisterType[[32]uint32]()
	serde.RegisterType[[32]uintptr]()
	serde.RegisterType[[33]float64]()
	serde.RegisterType[[3]byte]()
	serde.RegisterType[[3]int]()
	serde.RegisterType[[4096]byte]()
	serde.RegisterType[[40]int8]()
	serde.RegisterType[[4]byte]()
	serde.RegisterType[[4]float64]()
	serde.RegisterType[[4]string]()
	serde.RegisterType[[4]uint32]()
	serde.RegisterType[[4]uint64]()
	serde.RegisterType[[4]uintptr]()
	serde.RegisterType[[50]uintptr]()
	serde.RegisterType[[512]byte]()
	serde.RegisterType[[512]uintptr]()
	serde.RegisterType[[56]int8]()
	serde.RegisterType[[5]byte]()
	serde.RegisterType[[5]uint]()
	serde.RegisterType[[61]struct {
		Size    uint32
		Mallocs uint64
		Frees   uint64
	}]()
	serde.RegisterType[[64488]byte]()
	serde.RegisterType[[64]byte]()
	serde.RegisterType[[64]uint64]()
	serde.RegisterType[[64]uintptr]()
	serde.RegisterType[[65528]byte]()
	serde.RegisterType[[68]struct {
		Size    uint32
		Mallocs uint64
		Frees   uint64
	}]()
	serde.RegisterType[[68]uint16]()
	serde.RegisterType[[68]uint32]()
	serde.RegisterType[[68]uint64]()
	serde.RegisterType[[68]uint8]()
	serde.RegisterType[[6]int]()
	serde.RegisterType[[6]uintptr]()
	serde.RegisterType[[7]uint64]()
	serde.RegisterType[[88]byte]()
	serde.RegisterType[[8]byte]()
	serde.RegisterType[[8]int8]()
	serde.RegisterType[[8]string]()
	serde.RegisterType[[8]uint32]()
	serde.RegisterType[[8]uint8]()
	serde.RegisterType[[92]int8]()
	serde.RegisterType[[96]byte]()
	serde.RegisterType[[9]string]()
	serde.RegisterType[[]*byte]()
	serde.RegisterType[[][]int32]()
	serde.RegisterType[[]byte]()
	serde.RegisterType[[]float64]()
	serde.RegisterType[[]int]()
	serde.RegisterType[[]int16]()
	serde.RegisterType[[]int32]()
	serde.RegisterType[[]int64]()
	serde.RegisterType[[]int8]()
	serde.RegisterType[[]rune]()
	serde.RegisterType[[]string]()
	serde.RegisterType[[]uint16]()
	serde.RegisterType[[]uint32]()
	serde.RegisterType[[]uint64]()
	serde.RegisterType[[]uint8]()
	serde.RegisterType[[]uintptr]()
	serde.RegisterType[atomic.Bool]()
	serde.RegisterType[atomic.Int32]()
	serde.RegisterType[atomic.Int64]()
	serde.RegisterType[atomic.Uint32]()
	serde.RegisterType[atomic.Uint64]()
	serde.RegisterType[atomic.Uintptr]()
	serde.RegisterType[atomic.Value]()
	serde.RegisterType[bool]()
	serde.RegisterType[byte]()
	serde.RegisterType[complex128]()
	serde.RegisterType[float32]()
	serde.RegisterType[float64]()
	serde.RegisterType[int]()
	serde.RegisterType[int16]()
	serde.RegisterType[int32]()
	serde.RegisterType[int64]()
	serde.RegisterType[int8]()
	serde.RegisterType[map[*byte][]byte]()
	serde.RegisterType[map[int]int]()
	serde.RegisterType[map[int]struct{}]()
	serde.RegisterType[map[string]bool]()
	serde.RegisterType[map[string]int]()
	serde.RegisterType[map[string]uint64]()
	serde.RegisterType[rune]()
	serde.RegisterType[runtime.BlockProfileRecord]()
	serde.RegisterType[runtime.Frame]()
	serde.RegisterType[runtime.Frames]()
	serde.RegisterType[runtime.Func]()
	serde.RegisterType[runtime.MemProfileRecord]()
	serde.RegisterType[runtime.MemStats]()
	serde.RegisterType[runtime.PanicNilError]()
	serde.RegisterType[runtime.Pinner]()
	serde.RegisterType[runtime.StackRecord]()
	serde.RegisterType[runtime.TypeAssertionError]()
	serde.RegisterType[string]()
	serde.RegisterType[struct {
		b bool
		x any
	}]()
	serde.RegisterType[struct {
		base uintptr
		end  uintptr
	}]()
	serde.RegisterType[struct {
		enabled bool
		pad     [3]byte
		needed  bool
		alignme uint64
	}]()
	serde.RegisterType[struct {
		fd    int32
		cmd   int32
		arg   int32
		ret   int32
		errno int32
	}]()
	serde.RegisterType[struct {
		fill     uint64
		capacity uint64
	}]()
	serde.RegisterType[struct {
		fn  uintptr
		a1  uintptr
		a2  uintptr
		a3  uintptr
		a4  uintptr
		a5  uintptr
		a6  uintptr
		r1  uintptr
		r2  uintptr
		err uintptr
	}]()
	serde.RegisterType[struct {
		fn uintptr
		a1 uintptr
		a2 uintptr
		a3 uintptr
		a4 uintptr
		a5 uintptr
		f1 float64
		r1 uintptr
	}]()
	serde.RegisterType[struct {
		fn  uintptr
		a1  uintptr
		a2  uintptr
		a3  uintptr
		r1  uintptr
		r2  uintptr
		err uintptr
	}]()
	serde.RegisterType[struct {
		t     int64
		numer uint32
		denom uint32
	}]()
	serde.RegisterType[struct {
		tick uint64
		i    int
	}]()
	serde.RegisterType[struct{}]()
	serde.RegisterType[sync.Cond]()
	serde.RegisterType[sync.Map]()
	serde.RegisterType[sync.Mutex]()
	serde.RegisterType[sync.Once]()
	serde.RegisterType[sync.Pool]()
	serde.RegisterType[sync.RWMutex]()
	serde.RegisterType[sync.WaitGroup]()
	serde.RegisterType[syscall.BpfHdr]()
	serde.RegisterType[syscall.BpfInsn]()
	serde.RegisterType[syscall.BpfProgram]()
	serde.RegisterType[syscall.BpfStat]()
	serde.RegisterType[syscall.BpfVersion]()
	serde.RegisterType[syscall.Cmsghdr]()
	serde.RegisterType[syscall.Credential]()
	serde.RegisterType[syscall.Dirent]()
	serde.RegisterType[syscall.Errno]()
	serde.RegisterType[syscall.Fbootstraptransfer_t]()
	serde.RegisterType[syscall.FdSet]()
	serde.RegisterType[syscall.Flock_t]()
	serde.RegisterType[syscall.Fsid]()
	serde.RegisterType[syscall.Fstore_t]()
	serde.RegisterType[syscall.ICMPv6Filter]()
	serde.RegisterType[syscall.IPMreq]()
	serde.RegisterType[syscall.IPv6MTUInfo]()
	serde.RegisterType[syscall.IPv6Mreq]()
	serde.RegisterType[syscall.IfData]()
	serde.RegisterType[syscall.IfMsghdr]()
	serde.RegisterType[syscall.IfaMsghdr]()
	serde.RegisterType[syscall.IfmaMsghdr]()
	serde.RegisterType[syscall.IfmaMsghdr2]()
	serde.RegisterType[syscall.Inet4Pktinfo]()
	serde.RegisterType[syscall.Inet6Pktinfo]()
	serde.RegisterType[syscall.InterfaceAddrMessage]()
	serde.RegisterType[syscall.InterfaceMessage]()
	serde.RegisterType[syscall.InterfaceMulticastAddrMessage]()
	serde.RegisterType[syscall.Iovec]()
	serde.RegisterType[syscall.Kevent_t]()
	serde.RegisterType[syscall.Linger]()
	serde.RegisterType[syscall.Log2phys_t]()
	serde.RegisterType[syscall.Msghdr]()
	serde.RegisterType[syscall.ProcAttr]()
	serde.RegisterType[syscall.Radvisory_t]()
	serde.RegisterType[syscall.RawSockaddr]()
	serde.RegisterType[syscall.RawSockaddrAny]()
	serde.RegisterType[syscall.RawSockaddrDatalink]()
	serde.RegisterType[syscall.RawSockaddrInet4]()
	serde.RegisterType[syscall.RawSockaddrInet6]()
	serde.RegisterType[syscall.RawSockaddrUnix]()
	serde.RegisterType[syscall.Rlimit]()
	serde.RegisterType[syscall.RouteMessage]()
	serde.RegisterType[syscall.RtMetrics]()
	serde.RegisterType[syscall.RtMsghdr]()
	serde.RegisterType[syscall.Rusage]()
	serde.RegisterType[syscall.Signal]()
	serde.RegisterType[syscall.SockaddrDatalink]()
	serde.RegisterType[syscall.SockaddrInet4]()
	serde.RegisterType[syscall.SockaddrInet6]()
	serde.RegisterType[syscall.SockaddrUnix]()
	serde.RegisterType[syscall.SocketControlMessage]()
	serde.RegisterType[syscall.Stat_t]()
	serde.RegisterType[syscall.Statfs_t]()
	serde.RegisterType[syscall.SysProcAttr]()
	serde.RegisterType[syscall.Termios]()
	serde.RegisterType[syscall.Timespec]()
	serde.RegisterType[syscall.Timeval]()
	serde.RegisterType[syscall.Timeval32]()
	serde.RegisterType[syscall.WaitStatus]()
	serde.RegisterType[time.Duration]()
	serde.RegisterType[time.Location]()
	serde.RegisterType[time.Month]()
	serde.RegisterType[time.ParseError]()
	serde.RegisterType[time.Ticker]()
	serde.RegisterType[time.Time]()
	serde.RegisterType[time.Timer]()
	serde.RegisterType[time.Weekday]()
	serde.RegisterType[uint]()
	serde.RegisterType[uint16]()
	serde.RegisterType[uint32]()
	serde.RegisterType[uint64]()
	serde.RegisterType[uint8]()
	serde.RegisterType[uintptr]()
	serde.RegisterType[unsafe.Pointer]()
}
