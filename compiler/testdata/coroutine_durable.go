// Code generated by coroc. DO NOT EDIT

//go:build durable

package testdata

import (
	coroutine "github.com/stealthrocket/coroutine"
	time "time"
	unsafe "unsafe"
)

func SomeFunctionThatShouldExistInTheCompiledFile() {
}

//go:noinline
func Identity(n int) { coroutine.Yield[int, any](n) }

//go:noinline
func SquareGenerator(n int) {
	_c := coroutine.LoadContext[int, any]()
	_f, _fp := _c.Push()
	var _f0 *struct {
		X0 int
		X1 int
		X2 bool
	}
	if _f.IP == 0 {
		_f0 = &struct {
			X0 int
			X1 int
			X2 bool
		}{X0: n}
	} else {
		_f0 = _f.Get(0).(*struct {
			X0 int
			X1 int
			X2 bool
		})
	}
	defer func() {
		if _c.Unwinding() {
			_f.Set(0, _f0)
			_c.Store(_fp, _f)
		} else {
			_c.Pop()
		}
	}()
	switch {
	case _f.IP < 2:
		_f0.X1 = 1
		_f.IP = 2
		fallthrough
	case _f.IP < 5:
	_l0:
		for ; ; _f0.X1, _f.IP = _f0.X1+1, 2 {
			switch {
			case _f.IP < 4:
				switch {
				case _f.IP < 3:
					_f0.X2 = !(_f0.X1 <= _f0.X0)
					_f.IP = 3
					fallthrough
				case _f.IP < 4:
					if _f0.X2 {
						break _l0
					}
				}
				_f.IP = 4
				fallthrough
			case _f.IP < 5:
				coroutine.Yield[int, any](_f0.X1 * _f0.X1)
			}
		}
	}
}

//go:noinline
func SquareGeneratorTwice(n int) {
	_c := coroutine.LoadContext[int, any]()
	_f, _fp := _c.Push()
	var _f0 *struct {
		X0 int
	}
	if _f.IP == 0 {
		_f0 = &struct {
			X0 int
		}{X0: n}
	} else {
		_f0 = _f.Get(0).(*struct {
			X0 int
		})
	}
	defer func() {
		if _c.Unwinding() {
			_f.Set(0, _f0)
			_c.Store(_fp, _f)
		} else {
			_c.Pop()
		}
	}()
	switch {
	case _f.IP < 2:
		SquareGenerator(_f0.X0)
		_f.IP = 2
		fallthrough
	case _f.IP < 3:
		SquareGenerator(_f0.X0)
	}
}

//go:noinline
func SquareGeneratorTwiceLoop(n int) {
	_c := coroutine.LoadContext[int, any]()
	_f, _fp := _c.Push()
	var _f0 *struct {
		X0 int
		X1 int
		X2 bool
	}
	if _f.IP == 0 {
		_f0 = &struct {
			X0 int
			X1 int
			X2 bool
		}{X0: n}
	} else {
		_f0 = _f.Get(0).(*struct {
			X0 int
			X1 int
			X2 bool
		})
	}
	defer func() {
		if _c.Unwinding() {
			_f.Set(0, _f0)
			_c.Store(_fp, _f)
		} else {
			_c.Pop()
		}
	}()
	switch {
	case _f.IP < 2:
		_f0.X1 = 0
		_f.IP = 2
		fallthrough
	case _f.IP < 5:
	_l0:
		for ; ; _f0.X1, _f.IP = _f0.X1+1, 2 {
			switch {
			case _f.IP < 4:
				switch {
				case _f.IP < 3:
					_f0.X2 = !(_f0.X1 < 2)
					_f.IP = 3
					fallthrough
				case _f.IP < 4:
					if _f0.X2 {
						break _l0
					}
				}
				_f.IP = 4
				fallthrough
			case _f.IP < 5:
				SquareGenerator(_f0.X0)
			}
		}
	}
}

//go:noinline
func EvenSquareGenerator(n int) {
	_c := coroutine.LoadContext[int, any]()
	_f, _fp := _c.Push()
	var _f0 *struct {
		X0 int
		X1 int
		X2 bool
		X3 int
		X4 bool
	}
	if _f.IP == 0 {
		_f0 = &struct {
			X0 int
			X1 int
			X2 bool
			X3 int
			X4 bool
		}{X0: n}
	} else {
		_f0 = _f.Get(0).(*struct {
			X0 int
			X1 int
			X2 bool
			X3 int
			X4 bool
		})
	}
	defer func() {
		if _c.Unwinding() {
			_f.Set(0, _f0)
			_c.Store(_fp, _f)
		} else {
			_c.Pop()
		}
	}()
	switch {
	case _f.IP < 2:
		_f0.X1 = 1
		_f.IP = 2
		fallthrough
	case _f.IP < 7:
	_l0:
		for ; ; _f0.X1, _f.IP = _f0.X1+1, 2 {
			switch {
			case _f.IP < 4:
				switch {
				case _f.IP < 3:
					_f0.X2 = !(_f0.X1 <= _f0.X0)
					_f.IP = 3
					fallthrough
				case _f.IP < 4:
					if _f0.X2 {
						break _l0
					}
				}
				_f.IP = 4
				fallthrough
			case _f.IP < 7:
				switch {
				case _f.IP < 5:
					_f0.X3 = _f0.X1 % 2
					_f.IP = 5
					fallthrough
				case _f.IP < 6:
					_f0.X4 = _f0.X3 == 0
					_f.IP = 6
					fallthrough
				case _f.IP < 7:
					if _f0.X4 {
						coroutine.Yield[int, any](_f0.X1 * _f0.X1)
					}
				}
			}
		}
	}
}

//go:noinline
func NestedLoops(n int) {
	_c := coroutine.LoadContext[int, any]()
	_f, _fp := _c.Push()
	var _f0 *struct {
		X0 int
		X1 int
		X2 bool
		X3 int
		X4 bool
		X5 int
		X6 bool
	}
	if _f.IP == 0 {
		_f0 = &struct {
			X0 int
			X1 int
			X2 bool
			X3 int
			X4 bool
			X5 int
			X6 bool
		}{X0: n}
	} else {
		_f0 = _f.Get(0).(*struct {
			X0 int
			X1 int
			X2 bool
			X3 int
			X4 bool
			X5 int
			X6 bool
		})
	}
	defer func() {
		if _c.Unwinding() {
			_f.Set(0, _f0)
			_c.Store(_fp, _f)
		} else {
			_c.Pop()
		}
	}()
	switch {
	case _f.IP < 2:
		_f0.X1 = 1
		_f.IP = 2
		fallthrough
	case _f.IP < 11:
	_l0:
		for ; ; _f0.X1, _f.IP = _f0.X1+1, 2 {
			switch {
			case _f.IP < 4:
				switch {
				case _f.IP < 3:
					_f0.X2 = !(_f0.X1 <= _f0.X0)
					_f.IP = 3
					fallthrough
				case _f.IP < 4:
					if _f0.X2 {
						break _l0
					}
				}
				_f.IP = 4
				fallthrough
			case _f.IP < 11:
				switch {
				case _f.IP < 5:
					_f0.X3 = 1
					_f.IP = 5
					fallthrough
				case _f.IP < 11:
				_l1:
					for ; ; _f0.X3, _f.IP = _f0.X3+1, 5 {
						switch {
						case _f.IP < 7:
							switch {
							case _f.IP < 6:
								_f0.X4 = !(_f0.X3 <= _f0.X0)
								_f.IP = 6
								fallthrough
							case _f.IP < 7:
								if _f0.X4 {
									break _l1
								}
							}
							_f.IP = 7
							fallthrough
						case _f.IP < 11:
							switch {
							case _f.IP < 8:
								_f0.X5 = 1
								_f.IP = 8
								fallthrough
							case _f.IP < 11:
							_l2:
								for ; ; _f0.X5, _f.IP = _f0.X5+1, 8 {
									switch {
									case _f.IP < 10:
										switch {
										case _f.IP < 9:
											_f0.X6 = !(_f0.X5 <= _f0.X0)
											_f.IP = 9
											fallthrough
										case _f.IP < 10:
											if _f0.X6 {
												break _l2
											}
										}
										_f.IP = 10
										fallthrough
									case _f.IP < 11:
										coroutine.Yield[int, any](_f0.X1 * _f0.X3 * _f0.X5)
									}
								}
							}
						}
					}
				}
			}
		}
	}
}

//go:noinline
func FizzBuzzIfGenerator(n int) {
	_c := coroutine.LoadContext[int, any]()
	_f, _fp := _c.Push()
	var _f0 *struct {
		X0 int
		X1 int
		X2 bool
		X3 bool
		X4 bool
		X5 int
		X6 bool
	}
	if _f.IP == 0 {
		_f0 = &struct {
			X0 int
			X1 int
			X2 bool
			X3 bool
			X4 bool
			X5 int
			X6 bool
		}{X0: n}
	} else {
		_f0 = _f.Get(0).(*struct {
			X0 int
			X1 int
			X2 bool
			X3 bool
			X4 bool
			X5 int
			X6 bool
		})
	}
	defer func() {
		if _c.Unwinding() {
			_f.Set(0, _f0)
			_c.Store(_fp, _f)
		} else {
			_c.Pop()
		}
	}()
	switch {
	case _f.IP < 2:
		_f0.X1 = 1
		_f.IP = 2
		fallthrough
	case _f.IP < 12:
	_l0:
		for ; ; _f0.X1, _f.IP = _f0.X1+1, 2 {
			switch {
			case _f.IP < 4:
				switch {
				case _f.IP < 3:
					_f0.X2 = !(_f0.X1 <= _f0.X0)
					_f.IP = 3
					fallthrough
				case _f.IP < 4:
					if _f0.X2 {
						break _l0
					}
				}
				_f.IP = 4
				fallthrough
			case _f.IP < 12:
				switch {
				case _f.IP < 5:
					_f0.X3 = _f0.X1%
						3 == 0 && _f0.X1%5 == 0
					_f.IP = 5
					fallthrough
				case _f.IP < 12:
					if _f0.X3 {
						coroutine.Yield[int, any](FizzBuzz)
					} else {
						switch {
						case _f.IP < 7:
							_f0.X4 = _f0.X1%
								3 == 0
							_f.IP = 7
							fallthrough
						case _f.IP < 12:
							if _f0.X4 {
								coroutine.Yield[int, any](Fizz)
							} else {
								switch {
								case _f.IP < 9:
									_f0.X5 = _f0.X1 % 5
									_f.IP = 9
									fallthrough
								case _f.IP < 10:
									_f0.X6 = _f0.X5 == 0
									_f.IP = 10
									fallthrough
								case _f.IP < 12:
									if _f0.X6 {
										coroutine.Yield[int, any](Buzz)
									} else {

										coroutine.Yield[int, any](_f0.X1)
									}
								}
							}
						}
					}
				}
			}
		}
	}
}

//go:noinline
func FizzBuzzSwitchGenerator(n int) {
	_c := coroutine.LoadContext[int, any]()
	_f, _fp := _c.Push()
	var _f0 *struct {
		X0 int
		X1 int
		X2 bool
		X3 bool
		X4 bool
		X5 bool
	}
	if _f.IP == 0 {
		_f0 = &struct {
			X0 int
			X1 int
			X2 bool
			X3 bool
			X4 bool
			X5 bool
		}{X0: n}
	} else {
		_f0 = _f.Get(0).(*struct {
			X0 int
			X1 int
			X2 bool
			X3 bool
			X4 bool
			X5 bool
		})
	}
	defer func() {
		if _c.Unwinding() {
			_f.Set(0, _f0)
			_c.Store(_fp, _f)
		} else {
			_c.Pop()
		}
	}()
	switch {
	case _f.IP < 2:
		_f0.X1 = 1
		_f.IP = 2
		fallthrough
	case _f.IP < 11:
	_l0:
		for ; ; _f0.X1, _f.IP = _f0.X1+1, 2 {
			switch {
			case _f.IP < 4:
				switch {
				case _f.IP < 3:
					_f0.X2 = !(_f0.X1 <= _f0.X0)
					_f.IP = 3
					fallthrough
				case _f.IP < 4:
					if _f0.X2 {
						break _l0
					}
				}
				_f.IP = 4
				fallthrough
			case _f.IP < 11:
				switch {
				default:
					switch {
					case _f.IP < 5:
						_f0.X3 = _f0.X1%
							3 == 0 && _f0.X1%5 == 0
						_f.IP = 5
						fallthrough
					case _f.IP < 11:
						if _f0.X3 {
							coroutine.Yield[int, any](FizzBuzz)
						} else {
							switch {
							case _f.IP < 7:
								_f0.X4 = _f0.X1%
									3 == 0
								_f.IP = 7
								fallthrough
							case _f.IP < 11:
								if _f0.X4 {
									coroutine.Yield[int, any](Fizz)
								} else {
									switch {
									case _f.IP < 9:
										_f0.X5 = _f0.X1%
											5 == 0
										_f.IP = 9
										fallthrough
									case _f.IP < 11:
										if _f0.X5 {
											coroutine.Yield[int, any](Buzz)
										} else {

											coroutine.Yield[int, any](_f0.X1)
										}
									}
								}
							}
						}
					}
				}
			}
		}
	}
}

//go:noinline
func Shadowing(_ int) {
	_c := coroutine.LoadContext[int, any]()
	_f, _fp := _c.Push()

	const _o0 = 11

	const _o1 = 12

	type _o2 uint16

	type _o3 uint32

	const _o4 = 1
	type _o5 [_o4]uint8

	type _o6 [_o4]uint8

	const _o7 = unsafe.Sizeof(_o6{}) * 2
	type _o8 [_o7]uint8
	var _f0 *struct {
		X0  int
		X1  int
		X2  int
		X3  bool
		X4  int
		X5  int
		X6  bool
		X7  int
		X8  int
		X9  int
		X10 int
		X11 int
		X12 int
		X13 int
		X14 uintptr
		X15 int
		X16 uintptr
		X17 int
		X18 uintptr
		X19 int
		X20 uintptr
		X21 int
		X22 uintptr
		X23 int
	}
	if _f.IP == 0 {
		_f0 = &struct {
			X0  int
			X1  int
			X2  int
			X3  bool
			X4  int
			X5  int
			X6  bool
			X7  int
			X8  int
			X9  int
			X10 int
			X11 int
			X12 int
			X13 int
			X14 uintptr
			X15 int
			X16 uintptr
			X17 int
			X18 uintptr
			X19 int
			X20 uintptr
			X21 int
			X22 uintptr
			X23 int
		}{}
	} else {
		_f0 = _f.Get(0).(*struct {
			X0  int
			X1  int
			X2  int
			X3  bool
			X4  int
			X5  int
			X6  bool
			X7  int
			X8  int
			X9  int
			X10 int
			X11 int
			X12 int
			X13 int
			X14 uintptr
			X15 int
			X16 uintptr
			X17 int
			X18 uintptr
			X19 int
			X20 uintptr
			X21 int
			X22 uintptr
			X23 int
		})
	}
	defer func() {
		if _c.Unwinding() {
			_f.Set(0, _f0)
			_c.Store(_fp, _f)
		} else {
			_c.Pop()
		}
	}()
	switch {
	case _f.IP < 2:
		_f0.X0 = 0
		_f.IP = 2
		fallthrough
	case _f.IP < 3:
		coroutine.Yield[int, any](_f0.X0)
		_f.IP = 3
		fallthrough
	case _f.IP < 5:
		switch {
		case _f.IP < 4:
			_f0.X1 = 1
			_f.IP = 4
			fallthrough
		case _f.IP < 5:
			if true {
				coroutine.Yield[int, any](_f0.X1)
			}
		}
		_f.IP = 5
		fallthrough
	case _f.IP < 6:

		coroutine.Yield[int, any](_f0.X0)
		_f.IP = 6
		fallthrough
	case _f.IP < 10:
		switch {
		case _f.IP < 7:
			_f0.X2 = 1
			_f.IP = 7
			fallthrough
		case _f.IP < 10:
		_l0:
			for ; ; _f0.X2, _f.IP = _f0.X2+1, 7 {
				switch {
				case _f.IP < 9:
					switch {
					case _f.IP < 8:
						_f0.X3 = !(_f0.X2 < 3)
						_f.IP = 8
						fallthrough
					case _f.IP < 9:
						if _f0.X3 {
							break _l0
						}
					}
					_f.IP = 9
					fallthrough
				case _f.IP < 10:
					coroutine.Yield[int, any](_f0.X2)
				}
			}
		}
		_f.IP = 10
		fallthrough
	case _f.IP < 11:

		coroutine.Yield[int, any](_f0.X0)
		_f.IP = 11
		fallthrough
	case _f.IP < 18:
		switch {
		case _f.IP < 12:
			_f0.X4 = 1
			_f.IP = 12
			fallthrough
		case _f.IP < 13:
			_f0.X5 = _f0.X4
			_f.IP = 13
			fallthrough
		case _f.IP < 18:
			switch {
			default:
				switch {
				case _f.IP < 14:
					_f0.X6 = _f0.X5 ==
						1
					_f.IP = 14
					fallthrough
				case _f.IP < 18:
					if _f0.X6 {
						switch {
						case _f.IP < 17:
							switch {
							case _f.IP < 15:
								_f0.X7 = 2
								_f.IP = 15
								fallthrough
							case _f.IP < 16:
								_f0.X8 = _f0.X7
								_f.IP = 16
								fallthrough
							case _f.IP < 17:
								switch {
								default:

									coroutine.Yield[int, any](_f0.X7)
								}
							}
							_f.IP = 17
							fallthrough
						case _f.IP < 18:

							coroutine.Yield[int, any](_f0.X4)
						}
					}
				}
			}
		}
		_f.IP = 18
		fallthrough
	case _f.IP < 19:

		coroutine.Yield[int, any](_f0.X0)
		_f.IP = 19
		fallthrough
	case _f.IP < 23:
		switch {
		case _f.IP < 20:
			_f0.X9 = 1
			_f.IP = 20
			fallthrough
		case _f.IP < 22:
			switch {
			case _f.IP < 21:
				_f0.X10 = 2
				_f.IP = 21
				fallthrough
			case _f.IP < 22:
				coroutine.Yield[int, any](_f0.X10)
			}
			_f.IP = 22
			fallthrough
		case _f.IP < 23:

			coroutine.Yield[int, any](_f0.X9)
		}
		_f.IP = 23
		fallthrough
	case _f.IP < 24:

		coroutine.Yield[int, any](_f0.X0)
		_f.IP = 24
		fallthrough
	case _f.IP < 25:
		_f0.X11 = _f0.X0
		_f.IP = 25
		fallthrough
	case _f.IP < 27:
		switch {
		case _f.IP < 26:
			_f0.X12 = 1
			_f.IP = 26
			fallthrough
		case _f.IP < 27:
			coroutine.Yield[int, any](_f0.X12)
		}
		_f.IP = 27
		fallthrough
	case _f.IP < 28:

		coroutine.Yield[int, any](_f0.X11)
		_f.IP = 28
		fallthrough
	case _f.IP < 31:
		switch {
		case _f.IP < 30:
			switch {
			case _f.IP < 29:
				_f0.X13 = 13
				_f.IP = 29
				fallthrough
			case _f.IP < 30:
				coroutine.Yield[int, any](_f0.X13)
			}
			_f.IP = 30
			fallthrough
		case _f.IP < 31:

			coroutine.Yield[int, any](_o1)
		}
		_f.IP = 31
		fallthrough
	case _f.IP < 32:

		coroutine.Yield[int, any](_o0)
		_f.IP = 32
		fallthrough
	case _f.IP < 35:
		switch {
		case _f.IP < 33:
			_f0.X14 = unsafe.Sizeof(_o3(0))
			_f.IP = 33
			fallthrough
		case _f.IP < 34:
			_f0.X15 = int(_f0.X14)
			_f.IP = 34
			fallthrough
		case _f.IP < 35:
			coroutine.Yield[int, any](_f0.X15)
		}
		_f.IP = 35
		fallthrough
	case _f.IP < 36:
		_f0.X16 = unsafe.Sizeof(_o2(0))
		_f.IP = 36
		fallthrough
	case _f.IP < 37:
		_f0.X17 = int(_f0.X16)
		_f.IP = 37
		fallthrough
	case _f.IP < 38:
		coroutine.Yield[int, any](_f0.X17)
		_f.IP = 38
		fallthrough
	case _f.IP < 44:
		switch {
		case _f.IP < 39:
			_f0.X18 = unsafe.Sizeof(_o6{})
			_f.IP = 39
			fallthrough
		case _f.IP < 40:
			_f0.X19 = int(_f0.X18)
			_f.IP = 40
			fallthrough
		case _f.IP < 41:
			coroutine.Yield[int, any](_f0.X19)
			_f.IP = 41
			fallthrough
		case _f.IP < 42:
			_f0.X20 = unsafe.Sizeof(_o8{})
			_f.IP = 42
			fallthrough
		case _f.IP < 43:
			_f0.X21 = int(_f0.X20)
			_f.IP = 43
			fallthrough
		case _f.IP < 44:
			coroutine.Yield[int, any](_f0.X21)
		}
		_f.IP = 44
		fallthrough
	case _f.IP < 45:
		_f0.X22 = unsafe.Sizeof(_o5{})
		_f.IP = 45
		fallthrough
	case _f.IP < 46:
		_f0.X23 = int(_f0.X22)
		_f.IP = 46
		fallthrough
	case _f.IP < 47:
		coroutine.Yield[int, any](_f0.X23)
	}
}

//go:noinline
func RangeSliceIndexGenerator(_ int) {
	_c := coroutine.LoadContext[int, any]()
	_f, _fp := _c.Push()
	var _f0 *struct {
		X0 []int
		X1 int
		X2 bool
	}
	if _f.IP == 0 {
		_f0 = &struct {
			X0 []int
			X1 int
			X2 bool
		}{}
	} else {
		_f0 = _f.Get(0).(*struct {
			X0 []int
			X1 int
			X2 bool
		})
	}
	defer func() {
		if _c.Unwinding() {
			_f.Set(0, _f0)
			_c.Store(_fp, _f)
		} else {
			_c.Pop()
		}
	}()
	switch {
	case _f.IP < 2:
		_f0.X0 = []int{10, 20, 30}
		_f.IP = 2
		fallthrough
	case _f.IP < 6:
		switch {
		case _f.IP < 3:
			_f0.X1 = 0
			_f.IP = 3
			fallthrough
		case _f.IP < 6:
		_l0:
			for ; ; _f0.X1, _f.IP = _f0.X1+1, 3 {
				switch {
				case _f.IP < 5:
					switch {
					case _f.IP < 4:
						_f0.X2 = !(_f0.X1 < len(_f0.X0))
						_f.IP = 4
						fallthrough
					case _f.IP < 5:
						if _f0.X2 {
							break _l0
						}
					}
					_f.IP = 5
					fallthrough
				case _f.IP < 6:
					coroutine.Yield[int, any](_f0.X1)
				}
			}
		}
	}
}

//go:noinline
func RangeArrayIndexValueGenerator(_ int) {
	_c := coroutine.LoadContext[int, any]()
	_f, _fp := _c.Push()
	var _f0 *struct {
		X0 [3]int
		X1 int
		X2 bool
		X3 int
	}
	if _f.IP == 0 {
		_f0 = &struct {
			X0 [3]int
			X1 int
			X2 bool
			X3 int
		}{}
	} else {
		_f0 = _f.Get(0).(*struct {
			X0 [3]int
			X1 int
			X2 bool
			X3 int
		})
	}
	defer func() {
		if _c.Unwinding() {
			_f.Set(0, _f0)
			_c.Store(_fp, _f)
		} else {
			_c.Pop()
		}
	}()
	switch {
	case _f.IP < 2:
		_f0.X0 = [...]int{10, 20, 30}
		_f.IP = 2
		fallthrough
	case _f.IP < 8:
		switch {
		case _f.IP < 3:
			_f0.X1 = 0
			_f.IP = 3
			fallthrough
		case _f.IP < 8:
		_l0:
			for ; ; _f0.X1, _f.IP = _f0.X1+1, 3 {
				switch {
				case _f.IP < 5:
					switch {
					case _f.IP < 4:
						_f0.X2 = !(_f0.X1 < len(_f0.X0))
						_f.IP = 4
						fallthrough
					case _f.IP < 5:
						if _f0.X2 {
							break _l0
						}
					}
					_f.IP = 5
					fallthrough
				case _f.IP < 6:
					_f0.X3 = _f0.X0[_f0.X1]
					_f.IP = 6
					fallthrough
				case _f.IP < 7:
					coroutine.Yield[int, any](_f0.X1)
					_f.IP = 7
					fallthrough
				case _f.IP < 8:
					coroutine.Yield[int, any](_f0.X3)
				}
			}
		}
	}
}

//go:noinline
func TypeSwitchingGenerator(_ int) {
	_c := coroutine.LoadContext[int, any]()
	_f, _fp := _c.Push()
	var _f0 *struct {
		X0 []any
		X1 int
		X2 bool
		X3 any
		X4 any
		X5 any
	}
	if _f.IP == 0 {
		_f0 = &struct {
			X0 []any
			X1 int
			X2 bool
			X3 any
			X4 any
			X5 any
		}{}
	} else {
		_f0 = _f.Get(0).(*struct {
			X0 []any
			X1 int
			X2 bool
			X3 any
			X4 any
			X5 any
		})
	}
	defer func() {
		if _c.Unwinding() {
			_f.Set(0, _f0)
			_c.Store(_fp, _f)
		} else {
			_c.Pop()
		}
	}()
	switch {
	case _f.IP < 2:
		_f0.X0 = []any{int8(10), int16(20), int32(30), int64(40)}
		_f.IP = 2
		fallthrough
	case _f.IP < 16:
		switch {
		case _f.IP < 3:
			_f0.X1 = 0
			_f.IP = 3
			fallthrough
		case _f.IP < 16:
		_l0:
			for ; ; _f0.X1, _f.IP = _f0.X1+1, 3 {
				switch {
				case _f.IP < 5:
					switch {
					case _f.IP < 4:
						_f0.X2 = !(_f0.X1 < len(_f0.X0))
						_f.IP = 4
						fallthrough
					case _f.IP < 5:
						if _f0.X2 {
							break _l0
						}
					}
					_f.IP = 5
					fallthrough
				case _f.IP < 6:
					_f0.X3 = _f0.X0[_f0.X1]
					_f.IP = 6
					fallthrough
				case _f.IP < 11:
					switch {
					case _f.IP < 7:
						_f0.X4 = _f0.X3
						_f.IP = 7
						fallthrough
					case _f.IP < 11:
						switch _f0.X4.(type) {
						case int8:
							coroutine.Yield[int, any](1)
						case int16:
							coroutine.Yield[int, any](2)
						case int32:
							coroutine.Yield[int, any](4)
						case int64:
							coroutine.Yield[int, any](8)
						}
					}
					_f.IP = 11
					fallthrough
				case _f.IP < 16:
					switch {
					case _f.IP < 12:
						_f0.X5 = _f0.X3
						_f.IP = 12
						fallthrough
					case _f.IP < 16:
						switch v := _f0.X5.(type) {
						case int8:
							coroutine.Yield[int, any](int(v))
						case int16:
							coroutine.Yield[int, any](int(v))
						case int32:
							coroutine.Yield[int, any](int(v))
						case int64:
							coroutine.Yield[int, any](int(v))
						}
					}
				}
			}
		}
	}
}

//go:noinline
func LoopBreakAndContinue(_ int) {
	_c := coroutine.LoadContext[int, any]()
	_f, _fp := _c.Push()
	var _f0 *struct {
		X0  int
		X1  bool
		X2  int
		X3  bool
		X4  bool
		X5  int
		X6  bool
		X7  int
		X8  bool
		X9  int
		X10 bool
		X11 bool
		X12 int
		X13 bool
		X14 bool
	}
	if _f.IP == 0 {
		_f0 = &struct {
			X0  int
			X1  bool
			X2  int
			X3  bool
			X4  bool
			X5  int
			X6  bool
			X7  int
			X8  bool
			X9  int
			X10 bool
			X11 bool
			X12 int
			X13 bool
			X14 bool
		}{}
	} else {
		_f0 = _f.Get(0).(*struct {
			X0  int
			X1  bool
			X2  int
			X3  bool
			X4  bool
			X5  int
			X6  bool
			X7  int
			X8  bool
			X9  int
			X10 bool
			X11 bool
			X12 int
			X13 bool
			X14 bool
		})
	}
	defer func() {
		if _c.Unwinding() {
			_f.Set(0, _f0)
			_c.Store(_fp, _f)
		} else {
			_c.Pop()
		}
	}()
	switch {
	case _f.IP < 10:
		switch {
		case _f.IP < 2:
			_f0.X0 = 0
			_f.IP = 2
			fallthrough
		case _f.IP < 10:
		_l0:
			for ; ; _f0.X0, _f.IP = _f0.X0+1, 2 {
				switch {
				case _f.IP < 4:
					switch {
					case _f.IP < 3:
						_f0.X1 = !(_f0.X0 < 10)
						_f.IP = 3
						fallthrough
					case _f.IP < 4:
						if _f0.X1 {
							break _l0
						}
					}
					_f.IP = 4
					fallthrough
				case _f.IP < 7:
					switch {
					case _f.IP < 5:
						_f0.X2 = _f0.X0 % 2
						_f.IP = 5
						fallthrough
					case _f.IP < 6:
						_f0.X3 = _f0.X2 == 0
						_f.IP = 6
						fallthrough
					case _f.IP < 7:
						if _f0.X3 {
							continue _l0
						}
					}
					_f.IP = 7
					fallthrough
				case _f.IP < 9:
					switch {
					case _f.IP < 8:
						_f0.X4 = _f0.X0 >
							5
						_f.IP = 8
						fallthrough
					case _f.IP < 9:
						if _f0.X4 {
							break _l0
						}
					}
					_f.IP = 9
					fallthrough
				case _f.IP < 10:

					coroutine.Yield[int, any](_f0.X0)
				}
			}
		}
		_f.IP = 10
		fallthrough
	case _f.IP < 26:
		switch {
		case _f.IP < 11:
			_f0.X5 = 0
			_f.IP = 11
			fallthrough
		case _f.IP < 26:
		_l1:
			for ; ; _f0.X5, _f.IP = _f0.X5+1, 11 {
				switch {
				case _f.IP < 13:
					switch {
					case _f.IP < 12:
						_f0.X6 = !(_f0.X5 < 2)
						_f.IP = 12
						fallthrough
					case _f.IP < 13:
						if _f0.X6 {
							break _l1
						}
					}
					_f.IP = 13
					fallthrough
				case _f.IP < 26:
					switch {
					case _f.IP < 14:
						_f0.X7 = 0
						_f.IP = 14
						fallthrough
					case _f.IP < 26:
					_l2:
						for ; ; _f0.X7, _f.IP = _f0.X7+1, 14 {
							switch {
							case _f.IP < 16:
								switch {
								case _f.IP < 15:
									_f0.X8 = !(_f0.X7 < 3)
									_f.IP = 15
									fallthrough
								case _f.IP < 16:
									if _f0.X8 {
										break _l2
									}
								}
								_f.IP = 16
								fallthrough
							case _f.IP < 17:
								coroutine.Yield[int, any](_f0.X7)
								_f.IP = 17
								fallthrough
							case _f.IP < 26:
								switch {
								case _f.IP < 18:
									_f0.X9 = _f0.X7
									_f.IP = 18
									fallthrough
								case _f.IP < 26:
									switch {
									default:
										switch {
										case _f.IP < 19:
											_f0.X10 = _f0.X9 ==

												0
											_f.IP = 19
											fallthrough
										case _f.IP < 26:
											if _f0.X10 {
												continue _l2
											} else {
												switch {
												case _f.IP < 21:
													_f0.X11 = _f0.X9 ==

														1
													_f.IP = 21
													fallthrough
												case _f.IP < 26:
													if _f0.X11 {
														switch {
														case _f.IP < 22:
															_f0.X12 = _f0.X5
															_f.IP = 22
															fallthrough
														case _f.IP < 26:
															switch {
															default:
																switch {
																case _f.IP < 23:
																	_f0.X13 = _f0.X12 ==

																		0
																	_f.IP = 23
																	fallthrough
																case _f.IP < 26:
																	if _f0.X13 {
																		continue _l1
																	} else {
																		switch {
																		case _f.IP < 25:
																			_f0.X14 = _f0.X12 ==

																				1
																			_f.IP = 25
																			fallthrough
																		case _f.IP < 26:
																			if _f0.X14 {
																				break _l1
																			}
																		}
																	}
																}
															}
														}
													}
												}
											}
										}
									}
								}
							}
						}
					}
				}
			}
		}
	}
}

//go:noinline
func RangeOverMaps(n int) {
	_c := coroutine.LoadContext[int, any]()
	_f, _fp := _c.Push()
	var _f0 *struct {
		X0  int
		X1  map[int]int
		X2  map[int]int
		X3  int
		X4  bool
		X5  map[int]int
		X6  int
		X7  bool
		X8  map[int]int
		X9  int
		X10 bool
		X11 map[int]int
		X12 int
		X13 bool
		X14 map[int]int
		X15 []int
		X16 []int
		X17 int
		X18 bool
		X19 int
		X20 bool
		X21 map[int]int
		X22 []int
		X23 []int
		X24 int
		X25 bool
		X26 int
		X27 int
		X28 bool
		X29 map[int]struct {
		}
		X30 int
		X31 bool
		X32 map[int]struct {
		}
		X33 []int
		X34 []int
		X35 int
		X36 bool
		X37 int
		X38 bool
	}
	if _f.IP == 0 {
		_f0 = &struct {
			X0  int
			X1  map[int]int
			X2  map[int]int
			X3  int
			X4  bool
			X5  map[int]int
			X6  int
			X7  bool
			X8  map[int]int
			X9  int
			X10 bool
			X11 map[int]int
			X12 int
			X13 bool
			X14 map[int]int
			X15 []int
			X16 []int
			X17 int
			X18 bool
			X19 int
			X20 bool
			X21 map[int]int
			X22 []int
			X23 []int
			X24 int
			X25 bool
			X26 int
			X27 int
			X28 bool
			X29 map[int]struct {
			}
			X30 int
			X31 bool
			X32 map[int]struct {
			}
			X33 []int
			X34 []int
			X35 int
			X36 bool
			X37 int
			X38 bool
		}{X0: n}
	} else {
		_f0 = _f.Get(0).(*struct {
			X0  int
			X1  map[int]int
			X2  map[int]int
			X3  int
			X4  bool
			X5  map[int]int
			X6  int
			X7  bool
			X8  map[int]int
			X9  int
			X10 bool
			X11 map[int]int
			X12 int
			X13 bool
			X14 map[int]int
			X15 []int
			X16 []int
			X17 int
			X18 bool
			X19 int
			X20 bool
			X21 map[int]int
			X22 []int
			X23 []int
			X24 int
			X25 bool
			X26 int
			X27 int
			X28 bool
			X29 map[int]struct {
			}
			X30 int
			X31 bool
			X32 map[int]struct {
			}
			X33 []int
			X34 []int
			X35 int
			X36 bool
			X37 int
			X38 bool
		})
	}
	defer func() {
		if _c.Unwinding() {
			_f.Set(0, _f0)
			_c.Store(_fp, _f)
		} else {
			_c.Pop()
		}
	}()
	switch {
	case _f.IP < 2:
		_f0.X1 = map[int]int{}
		_f.IP = 2
		fallthrough
	case _f.IP < 7:
		switch {
		case _f.IP < 3:
			_f0.X2 = _f0.X1
			_f.IP = 3
			fallthrough
		case _f.IP < 7:
			switch {
			case _f.IP < 4:
				_f0.X3 = 0
				_f.IP = 4
				fallthrough
			case _f.IP < 7:
			_l0:
				for ; ; _f0.X3, _f.IP = _f0.X3+1, 4 {
					switch {
					case _f.IP < 6:
						switch {
						case _f.IP < 5:
							_f0.X4 = !(_f0.X3 < len(_f0.X2))
							_f.IP = 5
							fallthrough
						case _f.IP < 6:
							if _f0.X4 {
								break _l0
							}
						}
						_f.IP = 6
						fallthrough
					case _f.IP < 7:

						panic("unreachable")
					}
				}
			}
		}
		_f.IP = 7
		fallthrough
	case _f.IP < 12:
		switch {
		case _f.IP < 8:
			_f0.X5 = _f0.X1
			_f.IP = 8
			fallthrough
		case _f.IP < 12:
			switch {
			case _f.IP < 9:
				_f0.X6 = 0
				_f.IP = 9
				fallthrough
			case _f.IP < 12:
			_l1:
				for ; ; _f0.X6, _f.IP = _f0.X6+1, 9 {
					switch {
					case _f.IP < 11:
						switch {
						case _f.IP < 10:
							_f0.X7 = !(_f0.X6 < len(_f0.X5))
							_f.IP = 10
							fallthrough
						case _f.IP < 11:
							if _f0.X7 {
								break _l1
							}
						}
						_f.IP = 11
						fallthrough
					case _f.IP < 12:

						panic("unreachable")
					}
				}
			}
		}
		_f.IP = 12
		fallthrough
	case _f.IP < 17:
		switch {
		case _f.IP < 13:
			_f0.X8 = _f0.X1
			_f.IP = 13
			fallthrough
		case _f.IP < 17:
			switch {
			case _f.IP < 14:
				_f0.X9 = 0
				_f.IP = 14
				fallthrough
			case _f.IP < 17:
			_l2:
				for ; ; _f0.X9, _f.IP = _f0.X9+1, 14 {
					switch {
					case _f.IP < 16:
						switch {
						case _f.IP < 15:
							_f0.X10 = !(_f0.X9 < len(_f0.X8))
							_f.IP = 15
							fallthrough
						case _f.IP < 16:
							if _f0.X10 {
								break _l2
							}
						}
						_f.IP = 16
						fallthrough
					case _f.IP < 17:

						panic("unreachable")
					}
				}
			}
		}
		_f.IP = 17
		fallthrough
	case _f.IP < 18:
		_f0.X1[_f0.X0] = _f0.X0 * 10
		_f.IP = 18
		fallthrough
	case _f.IP < 23:
		switch {
		case _f.IP < 19:
			_f0.X11 = _f0.X1
			_f.IP = 19
			fallthrough
		case _f.IP < 23:
			switch {
			case _f.IP < 20:
				_f0.X12 = 0
				_f.IP = 20
				fallthrough
			case _f.IP < 23:
			_l3:
				for ; ; _f0.X12, _f.IP = _f0.X12+1, 20 {
					switch {
					case _f.IP < 22:
						switch {
						case _f.IP < 21:
							_f0.X13 = !(_f0.X12 < len(_f0.X11))
							_f.IP = 21
							fallthrough
						case _f.IP < 22:
							if _f0.X13 {
								break _l3
							}
						}
						_f.IP = 22
						fallthrough
					case _f.IP < 23:

						coroutine.Yield[int, any](0)
					}
				}
			}
		}
		_f.IP = 23
		fallthrough
	case _f.IP < 33:
		switch {
		case _f.IP < 24:
			_f0.X14 = _f0.X1
			_f.IP = 24
			fallthrough
		case _f.IP < 26:
			switch {
			case _f.IP < 25:
				_f0.X15 = make([]int, 0, len(_f0.X14))
				_f.IP = 25
				fallthrough
			case _f.IP < 26:
				for _v14 := range _f0.X14 {
					_f0.X15 = append(_f0.X15, _v14)
				}
			}
			_f.IP = 26
			fallthrough
		case _f.IP < 33:
			switch {
			case _f.IP < 27:
				_f0.X16 = _f0.X15
				_f.IP = 27
				fallthrough
			case _f.IP < 33:
				switch {
				case _f.IP < 28:
					_f0.X17 = 0
					_f.IP = 28
					fallthrough
				case _f.IP < 33:
				_l4:
					for ; ; _f0.X17, _f.IP = _f0.X17+1, 28 {
						switch {
						case _f.IP < 30:
							switch {
							case _f.IP < 29:
								_f0.X18 = !(_f0.X17 < len(_f0.X16))
								_f.IP = 29
								fallthrough
							case _f.IP < 30:
								if _f0.X18 {
									break _l4
								}
							}
							_f.IP = 30
							fallthrough
						case _f.IP < 31:
							_f0.X19 = _f0.X16[_f0.X17]
							_f.IP = 31
							fallthrough
						case _f.IP < 33:
							switch {
							case _f.IP < 32:
								_, _f0.X20 = _f0.X14[_f0.X19]
								_f.IP = 32
								fallthrough
							case _f.IP < 33:
								if _f0.X20 {

									coroutine.Yield[int, any](_f0.X19)
								}
							}
						}
					}
				}
			}
		}
		_f.IP = 33
		fallthrough
	case _f.IP < 44:
		switch {
		case _f.IP < 34:
			_f0.X21 = _f0.X1
			_f.IP = 34
			fallthrough
		case _f.IP < 36:
			switch {
			case _f.IP < 35:
				_f0.X22 = make([]int, 0, len(_f0.X21))
				_f.IP = 35
				fallthrough
			case _f.IP < 36:
				for _v21 := range _f0.X21 {
					_f0.X22 = append(_f0.X22, _v21)
				}
			}
			_f.IP = 36
			fallthrough
		case _f.IP < 44:
			switch {
			case _f.IP < 37:
				_f0.X23 = _f0.X22
				_f.IP = 37
				fallthrough
			case _f.IP < 44:
				switch {
				case _f.IP < 38:
					_f0.X24 = 0
					_f.IP = 38
					fallthrough
				case _f.IP < 44:
				_l5:
					for ; ; _f0.X24, _f.IP = _f0.X24+1, 38 {
						switch {
						case _f.IP < 40:
							switch {
							case _f.IP < 39:
								_f0.X25 = !(_f0.X24 < len(_f0.X23))
								_f.IP = 39
								fallthrough
							case _f.IP < 40:
								if _f0.X25 {
									break _l5
								}
							}
							_f.IP = 40
							fallthrough
						case _f.IP < 41:
							_f0.X26 = _f0.X23[_f0.X24]
							_f.IP = 41
							fallthrough
						case _f.IP < 44:
							switch {
							case _f.IP < 42:
								_f0.X27, _f0.X28 = _f0.X21[_f0.X26]
								_f.IP = 42
								fallthrough
							case _f.IP < 44:
								if _f0.X28 {
									switch {
									case _f.IP < 43:

										coroutine.Yield[int, any](_f0.X26)
										_f.IP = 43
										fallthrough
									case _f.IP < 44:
										coroutine.Yield[int, any](_f0.X27)
									}
								}
							}
						}
					}
				}
			}
		}
		_f.IP = 44
		fallthrough
	case _f.IP < 45:
		_f0.X29 = make(map[int]struct{}, _f0.X0)
		_f.IP = 45
		fallthrough
	case _f.IP < 49:
		switch {
		case _f.IP < 46:
			_f0.X30 = 0
			_f.IP = 46
			fallthrough
		case _f.IP < 49:
		_l6:
			for ; ; _f0.X30, _f.IP = _f0.X30+1, 46 {
				switch {
				case _f.IP < 48:
					switch {
					case _f.IP < 47:
						_f0.X31 = !(_f0.X30 < _f0.X0)
						_f.IP = 47
						fallthrough
					case _f.IP < 48:
						if _f0.X31 {
							break _l6
						}
					}
					_f.IP = 48
					fallthrough
				case _f.IP < 49:
					_f0.X29[_f0.X30] = struct{}{}
				}
			}
		}
		_f.IP = 49
		fallthrough
	case _f.IP < 50:

		coroutine.Yield[int, any](len(_f0.X29))
		_f.IP = 50
		fallthrough
	case _f.IP < 61:
		switch {
		case _f.IP < 51:
			_f0.X32 = _f0.X29
			_f.IP = 51
			fallthrough
		case _f.IP < 53:
			switch {
			case _f.IP < 52:
				_f0.X33 = make([]int, 0, len(_f0.X32))
				_f.IP = 52
				fallthrough
			case _f.IP < 53:
				for _v29 := range _f0.X32 {
					_f0.X33 = append(_f0.X33, _v29)
				}
			}
			_f.IP = 53
			fallthrough
		case _f.IP < 61:
			switch {
			case _f.IP < 54:
				_f0.X34 = _f0.X33
				_f.IP = 54
				fallthrough
			case _f.IP < 61:
				switch {
				case _f.IP < 55:
					_f0.X35 = 0
					_f.IP = 55
					fallthrough
				case _f.IP < 61:
				_l7:
					for ; ; _f0.X35, _f.IP = _f0.X35+1, 55 {
						switch {
						case _f.IP < 57:
							switch {
							case _f.IP < 56:
								_f0.X36 = !(_f0.X35 < len(_f0.X34))
								_f.IP = 56
								fallthrough
							case _f.IP < 57:
								if _f0.X36 {
									break _l7
								}
							}
							_f.IP = 57
							fallthrough
						case _f.IP < 58:
							_f0.X37 = _f0.X34[_f0.X35]
							_f.IP = 58
							fallthrough
						case _f.IP < 61:
							switch {
							case _f.IP < 59:
								_, _f0.X38 = _f0.X32[_f0.X37]
								_f.IP = 59
								fallthrough
							case _f.IP < 61:
								if _f0.X38 {
									switch {
									case _f.IP < 60:

										delete(_f0.X29, _f0.X37)
										_f.IP = 60
										fallthrough
									case _f.IP < 61:
										coroutine.Yield[int, any](len(_f0.X29))
									}
								}
							}
						}
					}
				}
			}
		}
	}
}

//go:noinline
func Range(n int, do func(int)) {
	_c := coroutine.LoadContext[int, any]()
	_f, _fp := _c.Push()
	var _f0 *struct {
		X0 int
		X1 func(int)
		X2 int
		X3 bool
	}
	if _f.IP == 0 {
		_f0 = &struct {
			X0 int
			X1 func(int)
			X2 int
			X3 bool
		}{X0: n, X1: do}
	} else {
		_f0 = _f.Get(0).(*struct {
			X0 int
			X1 func(int)
			X2 int
			X3 bool
		})
	}
	defer func() {
		if _c.Unwinding() {
			_f.Set(0, _f0)
			_c.Store(_fp, _f)
		} else {
			_c.Pop()
		}
	}()
	switch {
	case _f.IP < 2:
		_f0.X2 = 0
		_f.IP = 2
		fallthrough
	case _f.IP < 5:
	_l0:
		for ; ; _f0.X2, _f.IP = _f0.X2+1, 2 {
			switch {
			case _f.IP < 4:
				switch {
				case _f.IP < 3:
					_f0.X3 = !(_f0.X2 < _f0.X0)
					_f.IP = 3
					fallthrough
				case _f.IP < 4:
					if _f0.X3 {
						break _l0
					}
				}
				_f.IP = 4
				fallthrough
			case _f.IP < 5:
				_f0.X1(_f0.X2)
			}
		}
	}
}

//go:noinline
func Double(n int) { coroutine.Yield[int, any](2 * n) }

//go:noinline
func RangeTriple(n int) {
	Range(n, func(i int) { coroutine.Yield[int, any](3 * i) })
}

//go:noinline
func RangeTripleFuncValue(n int) {
	_c := coroutine.LoadContext[int, any]()
	_f, _fp := _c.Push()
	var _f0 *struct {
		X0 int
		X1 func(int)
	}
	if _f.IP == 0 {
		_f0 = &struct {
			X0 int
			X1 func(int)
		}{X0: n}
	} else {
		_f0 = _f.Get(0).(*struct {
			X0 int
			X1 func(int)
		})
	}
	defer func() {
		if _c.Unwinding() {
			_f.Set(0, _f0)
			_c.Store(_fp, _f)
		} else {
			_c.Pop()
		}
	}()
	switch {
	case _f.IP < 2:
		_f0.X1 = func(i int) { coroutine.Yield[int, any](3 * i) }
		_f.IP = 2
		fallthrough
	case _f.IP < 3:

		Range(_f0.X0, _f0.X1)
	}
}

//go:noinline
func RangeReverseClosureCaptureByValue(n int) {
	_c := coroutine.LoadContext[int, any]()
	_f, _fp := _c.Push()
	var _f0 *struct {
		X0 int
		X1 int
		X2 func()
		X3 bool
	}
	if _f.IP == 0 {
		_f0 = &struct {
			X0 int
			X1 int
			X2 func()
			X3 bool
		}{X0: n}
	} else {
		_f0 = _f.Get(0).(*struct {
			X0 int
			X1 int
			X2 func()
			X3 bool
		})
	}
	defer func() {
		if _c.Unwinding() {
			_f.Set(0, _f0)
			_c.Store(_fp, _f)
		} else {
			_c.Pop()
		}
	}()
	switch {
	case _f.IP < 2:
		_f0.X1 = 0
		_f.IP = 2
		fallthrough
	case _f.IP < 3:
		_f0.X2 = func() { coroutine.Yield[int, any](_f0.X0 - (_f0.X1 + 1)) }
		_f.IP = 3
		fallthrough
	case _f.IP < 7:
	_l0:
		for ; ; _f.IP = 3 {
			switch {
			case _f.IP < 5:
				switch {
				case _f.IP < 4:
					_f0.X3 = !(_f0.X1 < _f0.X0)
					_f.IP = 4
					fallthrough
				case _f.IP < 5:
					if _f0.X3 {
						break _l0
					}
				}
				_f.IP = 5
				fallthrough
			case _f.IP < 6:
				_f0.X2()
				_f.IP = 6
				fallthrough
			case _f.IP < 7:
				_f0.X1++
			}
		}
	}
}

//go:noinline
func Range10ClosureCapturingValues() {
	_c := coroutine.LoadContext[int, any]()
	_f, _fp := _c.Push()
	var _f1 *struct {
		X0 int
		X1 int
		X2 func() bool
		X3 bool
		X4 bool
	}
	if _f.IP == 0 {
		_f1 = &struct {
			X0 int
			X1 int
			X2 func() bool
			X3 bool
			X4 bool
		}{}
	} else {
		_f1 = _f.Get(0).(*struct {
			X0 int
			X1 int
			X2 func() bool
			X3 bool
			X4 bool
		})
	}
	defer func() {
		if _c.Unwinding() {
			_f.Set(0, _f1)
			_c.Store(_fp, _f)
		} else {
			_c.Pop()
		}
	}()
	switch {
	case _f.IP < 2:
		_f1.X0 = 0
		_f.IP = 2
		fallthrough
	case _f.IP < 3:
		_f1.X1 = 10
		_f.IP = 3
		fallthrough
	case _f.IP < 4:
		_f1.X2 = func() (_ bool) {
			_c := coroutine.LoadContext[int, any]()
			_f, _fp := _c.Push()
			var _f0 *struct {
				X0 bool
			}
			if _f.IP == 0 {
				_f0 = &struct {
					X0 bool
				}{}
			} else {
				_f0 = _f.Get(0).(*struct {
					X0 bool
				})
			}
			defer func() {
				if _c.Unwinding() {
					_f.Set(0, _f0)
					_c.Store(_fp, _f)
				} else {
					_c.Pop()
				}
			}()
			switch {
			case _f.IP < 5:
				switch {
				case _f.IP < 2:
					_f0.X0 = _f1.X0 < _f1.X1
					_f.IP = 2
					fallthrough
				case _f.IP < 5:
					if _f0.X0 {
						switch {
						case _f.IP < 3:
							coroutine.Yield[int, any](_f1.X0)
							_f.IP = 3
							fallthrough
						case _f.IP < 4:
							_f1.X0++
							_f.IP = 4
							fallthrough
						case _f.IP < 5:
							return true
						}
					}
				}
				_f.IP = 5
				fallthrough
			case _f.IP < 6:

				return false
			}
			return
		}
		_f.IP = 4
		fallthrough
	case _f.IP < 7:
	_l0:
		for ; ; _f.IP = 4 {
			switch {
			case _f.IP < 5:
				_f1.X3 = _f1.X2()
				_f.IP = 5
				fallthrough
			case _f.IP < 6:
				_f1.X4 = !_f1.X3
				_f.IP = 6
				fallthrough
			case _f.IP < 7:
				if _f1.X4 {
					break _l0
				}
			}
		}
	}
}

//go:noinline
func Range10ClosureCapturingPointers() {
	_c := coroutine.LoadContext[int, any]()
	_f, _fp := _c.Push()
	var _f1 *struct {
		X0 int
		X1 int
		X2 *int
		X3 *int
		X4 func() bool
		X5 bool
		X6 bool
	}
	if _f.IP == 0 {
		_f1 = &struct {
			X0 int
			X1 int
			X2 *int
			X3 *int
			X4 func() bool
			X5 bool
			X6 bool
		}{}
	} else {
		_f1 = _f.Get(0).(*struct {
			X0 int
			X1 int
			X2 *int
			X3 *int
			X4 func() bool
			X5 bool
			X6 bool
		})
	}
	defer func() {
		if _c.Unwinding() {
			_f.Set(0, _f1)
			_c.Store(_fp, _f)
		} else {
			_c.Pop()
		}
	}()
	switch {
	case _f.IP < 2:
		_f1.X0, _f1.X1 = 0, 10
		_f.IP = 2
		fallthrough
	case _f.IP < 3:
		_f1.X2 = &_f1.X0
		_f.IP = 3
		fallthrough
	case _f.IP < 4:
		_f1.X3 = &_f1.X1
		_f.IP = 4
		fallthrough
	case _f.IP < 5:
		_f1.X4 = func() (_ bool) {
			_c := coroutine.LoadContext[int, any]()
			_f, _fp := _c.Push()
			var _f0 *struct {
				X0 bool
			}
			if _f.IP == 0 {
				_f0 = &struct {
					X0 bool
				}{}
			} else {
				_f0 = _f.Get(0).(*struct {
					X0 bool
				})
			}
			defer func() {
				if _c.Unwinding() {
					_f.Set(0, _f0)
					_c.Store(_fp, _f)
				} else {
					_c.Pop()
				}
			}()
			switch {
			case _f.IP < 5:
				switch {
				case _f.IP < 2:
					_f0.X0 = *_f1.X2 < *_f1.X3
					_f.IP = 2
					fallthrough
				case _f.IP < 5:
					if _f0.X0 {
						switch {
						case _f.IP < 3:
							coroutine.Yield[int, any](*_f1.X2)
							_f.IP = 3
							fallthrough
						case _f.IP < 4:
							(*_f1.X2)++
							_f.IP = 4
							fallthrough
						case _f.IP < 5:
							return true
						}
					}
				}
				_f.IP = 5
				fallthrough
			case _f.IP < 6:

				return false
			}
			return
		}
		_f.IP = 5
		fallthrough
	case _f.IP < 8:
	_l0:
		for ; ; _f.IP = 5 {
			switch {
			case _f.IP < 6:
				_f1.X5 = _f1.X4()
				_f.IP = 6
				fallthrough
			case _f.IP < 7:
				_f1.X6 = !_f1.X5
				_f.IP = 7
				fallthrough
			case _f.IP < 8:
				if _f1.X6 {
					break _l0
				}
			}
		}
	}
}

//go:noinline
func Range10ClosureHeterogenousCapture() {
	_c := coroutine.LoadContext[int, any]()
	_f, _fp := _c.Push()
	var _f1 *struct {
		X0  int8
		X1  int16
		X2  int32
		X3  int64
		X4  uint8
		X5  uint16
		X6  uint32
		X7  uint64
		X8  uintptr
		X9  func() int
		X10 int
		X11 func() bool
		X12 bool
		X13 bool
	}
	if _f.IP == 0 {
		_f1 = &struct {
			X0  int8
			X1  int16
			X2  int32
			X3  int64
			X4  uint8
			X5  uint16
			X6  uint32
			X7  uint64
			X8  uintptr
			X9  func() int
			X10 int
			X11 func() bool
			X12 bool
			X13 bool
		}{}
	} else {
		_f1 = _f.Get(0).(*struct {
			X0  int8
			X1  int16
			X2  int32
			X3  int64
			X4  uint8
			X5  uint16
			X6  uint32
			X7  uint64
			X8  uintptr
			X9  func() int
			X10 int
			X11 func() bool
			X12 bool
			X13 bool
		})
	}
	defer func() {
		if _c.Unwinding() {
			_f.Set(0, _f1)
			_c.Store(_fp, _f)
		} else {
			_c.Pop()
		}
	}()
	switch {
	case _f.IP < 11:
		switch {
		case _f.IP < 2:
			_f1.X0 = 0
			_f.IP = 2
			fallthrough
		case _f.IP < 3:
			_f1.X1 = 1
			_f.IP = 3
			fallthrough
		case _f.IP < 4:
			_f1.X2 = 2
			_f.IP = 4
			fallthrough
		case _f.IP < 5:
			_f1.X3 = 3
			_f.IP = 5
			fallthrough
		case _f.IP < 6:
			_f1.X4 = 4
			_f.IP = 6
			fallthrough
		case _f.IP < 7:
			_f1.X5 = 5
			_f.IP = 7
			fallthrough
		case _f.IP < 8:
			_f1.X6 = 6
			_f.IP = 8
			fallthrough
		case _f.IP < 9:
			_f1.X7 = 7
			_f.IP = 9
			fallthrough
		case _f.IP < 10:
			_f1.X8 = 8
			_f.IP = 10
			fallthrough
		case _f.IP < 11:
			_f1.X9 = func() int { return int(_f1.X8) + 1 }
		}
		_f.IP = 11
		fallthrough
	case _f.IP < 12:
		_f1.X10 = 0
		_f.IP = 12
		fallthrough
	case _f.IP < 13:
		_f1.X11 = func() (_ bool) {
			_c := coroutine.LoadContext[int, any]()
			_f, _fp := _c.Push()
			var _f0 *struct {
				X0  int
				X1  int
				X2  bool
				X3  bool
				X4  bool
				X5  bool
				X6  bool
				X7  bool
				X8  bool
				X9  bool
				X10 bool
				X11 bool
				X12 int
			}
			if _f.IP == 0 {
				_f0 = &struct {
					X0  int
					X1  int
					X2  bool
					X3  bool
					X4  bool
					X5  bool
					X6  bool
					X7  bool
					X8  bool
					X9  bool
					X10 bool
					X11 bool
					X12 int
				}{}
			} else {
				_f0 = _f.Get(0).(*struct {
					X0  int
					X1  int
					X2  bool
					X3  bool
					X4  bool
					X5  bool
					X6  bool
					X7  bool
					X8  bool
					X9  bool
					X10 bool
					X11 bool
					X12 int
				})
			}
			defer func() {
				if _c.Unwinding() {
					_f.Set(0, _f0)
					_c.Store(_fp, _f)
				} else {
					_c.Pop()
				}
			}()
			switch {
			case _f.IP < 2:
				_f.IP = 2
				fallthrough
			case _f.IP < 24:
				switch {
				case _f.IP < 3:
					_f0.X1 = _f1.X10
					_f.IP = 3
					fallthrough
				case _f.IP < 24:
					switch {
					default:
						switch {
						case _f.IP < 4:
							_f0.X2 = _f0.X1 ==

								0
							_f.IP = 4
							fallthrough
						case _f.IP < 24:
							if _f0.X2 {
								_f0.X0 = int(_f1.X0)
							} else {
								switch {
								case _f.IP < 6:
									_f0.X3 = _f0.X1 ==
										1
									_f.IP = 6
									fallthrough
								case _f.IP < 24:
									if _f0.X3 {
										_f0.X0 = int(_f1.X1)
									} else {
										switch {
										case _f.IP < 8:
											_f0.X4 = _f0.X1 ==
												2
											_f.IP = 8
											fallthrough
										case _f.IP < 24:
											if _f0.X4 {
												_f0.X0 = int(_f1.X2)
											} else {
												switch {
												case _f.IP < 10:
													_f0.X5 = _f0.X1 ==
														3
													_f.IP = 10
													fallthrough
												case _f.IP < 24:
													if _f0.X5 {
														_f0.X0 = int(_f1.X3)
													} else {
														switch {
														case _f.IP < 12:
															_f0.X6 = _f0.X1 ==
																4
															_f.IP = 12
															fallthrough
														case _f.IP < 24:
															if _f0.X6 {
																_f0.X0 = int(_f1.X4)
															} else {
																switch {
																case _f.IP < 14:
																	_f0.X7 = _f0.X1 ==
																		5
																	_f.IP = 14
																	fallthrough
																case _f.IP < 24:
																	if _f0.X7 {
																		_f0.X0 = int(_f1.X5)
																	} else {
																		switch {
																		case _f.IP < 16:
																			_f0.X8 = _f0.X1 ==
																				6
																			_f.IP = 16
																			fallthrough
																		case _f.IP < 24:
																			if _f0.X8 {
																				_f0.X0 = int(_f1.X6)
																			} else {
																				switch {
																				case _f.IP < 18:
																					_f0.X9 = _f0.X1 ==
																						7
																					_f.IP = 18
																					fallthrough
																				case _f.IP < 24:
																					if _f0.X9 {
																						_f0.X0 = int(_f1.X7)
																					} else {
																						switch {
																						case _f.IP < 20:
																							_f0.X10 = _f0.X1 ==
																								8
																							_f.IP = 20
																							fallthrough
																						case _f.IP < 24:
																							if _f0.X10 {
																								_f0.X0 = int(_f1.X8)
																							} else {
																								switch {
																								case _f.IP < 22:
																									_f0.X11 = _f0.X1 ==
																										9
																									_f.IP = 22
																									fallthrough
																								case _f.IP < 24:
																									if _f0.X11 {
																										switch {
																										case _f.IP < 23:
																											_f0.X12 = _f1.X9()
																											_f.IP = 23
																											fallthrough
																										case _f.IP < 24:
																											_f0.X0 = _f0.X12
																										}
																									}
																								}
																							}
																						}
																					}
																				}
																			}
																		}
																	}
																}
															}
														}
													}
												}
											}
										}
									}
								}
							}
						}
					}
				}
				_f.IP = 24
				fallthrough
			case _f.IP < 25:

				coroutine.Yield[int, any](_f0.X0)
				_f.IP = 25
				fallthrough
			case _f.IP < 26:
				_f1.X10++
				_f.IP = 26
				fallthrough
			case _f.IP < 27:
				return _f1.X10 < 10
			}
			return
		}
		_f.IP = 13
		fallthrough
	case _f.IP < 16:
	_l0:
		for ; ; _f.IP = 13 {
			switch {
			case _f.IP < 14:
				_f1.X12 = _f1.X11()
				_f.IP = 14
				fallthrough
			case _f.IP < 15:
				_f1.X13 = !_f1.X12
				_f.IP = 15
				fallthrough
			case _f.IP < 16:
				if _f1.X13 {
					break _l0
				}
			}
		}
	}
}

//go:noinline
func Range10Heterogenous() {
	_c := coroutine.LoadContext[int, any]()
	_f, _fp := _c.Push()
	var _f0 *struct {
		X0  int8
		X1  int16
		X2  int32
		X3  int64
		X4  uint8
		X5  uint16
		X6  uint32
		X7  uint64
		X8  uintptr
		X9  int
		X10 bool
		X11 int
		X12 int
		X13 bool
		X14 bool
		X15 bool
		X16 bool
		X17 bool
		X18 bool
		X19 bool
		X20 bool
		X21 bool
		X22 bool
	}
	if _f.IP == 0 {
		_f0 = &struct {
			X0  int8
			X1  int16
			X2  int32
			X3  int64
			X4  uint8
			X5  uint16
			X6  uint32
			X7  uint64
			X8  uintptr
			X9  int
			X10 bool
			X11 int
			X12 int
			X13 bool
			X14 bool
			X15 bool
			X16 bool
			X17 bool
			X18 bool
			X19 bool
			X20 bool
			X21 bool
			X22 bool
		}{}
	} else {
		_f0 = _f.Get(0).(*struct {
			X0  int8
			X1  int16
			X2  int32
			X3  int64
			X4  uint8
			X5  uint16
			X6  uint32
			X7  uint64
			X8  uintptr
			X9  int
			X10 bool
			X11 int
			X12 int
			X13 bool
			X14 bool
			X15 bool
			X16 bool
			X17 bool
			X18 bool
			X19 bool
			X20 bool
			X21 bool
			X22 bool
		})
	}
	defer func() {
		if _c.Unwinding() {
			_f.Set(0, _f0)
			_c.Store(_fp, _f)
		} else {
			_c.Pop()
		}
	}()
	switch {
	case _f.IP < 10:
		switch {
		case _f.IP < 2:
			_f0.X0 = 0
			_f.IP = 2
			fallthrough
		case _f.IP < 3:
			_f0.X1 = 1
			_f.IP = 3
			fallthrough
		case _f.IP < 4:
			_f0.X2 = 2
			_f.IP = 4
			fallthrough
		case _f.IP < 5:
			_f0.X3 = 3
			_f.IP = 5
			fallthrough
		case _f.IP < 6:
			_f0.X4 = 4
			_f.IP = 6
			fallthrough
		case _f.IP < 7:
			_f0.X5 = 5
			_f.IP = 7
			fallthrough
		case _f.IP < 8:
			_f0.X6 = 6
			_f.IP = 8
			fallthrough
		case _f.IP < 9:
			_f0.X7 = 7
			_f.IP = 9
			fallthrough
		case _f.IP < 10:
			_f0.X8 = 8
		}
		_f.IP = 10
		fallthrough
	case _f.IP < 36:
		switch {
		case _f.IP < 11:
			_f0.X9 = 0
			_f.IP = 11
			fallthrough
		case _f.IP < 36:
		_l0:
			for ; ; _f0.X9, _f.IP = _f0.X9+1, 11 {
				switch {
				case _f.IP < 13:
					switch {
					case _f.IP < 12:
						_f0.X10 = !(_f0.X9 < 10)
						_f.IP = 12
						fallthrough
					case _f.IP < 13:
						if _f0.X10 {
							break _l0
						}
					}
					_f.IP = 13
					fallthrough
				case _f.IP < 14:
					_f.IP = 14
					fallthrough
				case _f.IP < 35:
					switch {
					case _f.IP < 15:
						_f0.X12 = _f0.X9
						_f.IP = 15
						fallthrough
					case _f.IP < 35:
						switch {
						default:
							switch {
							case _f.IP < 16:
								_f0.X13 = _f0.X12 ==

									0
								_f.IP = 16
								fallthrough
							case _f.IP < 35:
								if _f0.X13 {
									_f0.X11 = int(_f0.X0)
								} else {
									switch {
									case _f.IP < 18:
										_f0.X14 = _f0.X12 ==
											1
										_f.IP = 18
										fallthrough
									case _f.IP < 35:
										if _f0.X14 {
											_f0.X11 = int(_f0.X1)
										} else {
											switch {
											case _f.IP < 20:
												_f0.X15 = _f0.X12 ==
													2
												_f.IP = 20
												fallthrough
											case _f.IP < 35:
												if _f0.X15 {
													_f0.X11 = int(_f0.X2)
												} else {
													switch {
													case _f.IP < 22:
														_f0.X16 = _f0.X12 ==
															3
														_f.IP = 22
														fallthrough
													case _f.IP < 35:
														if _f0.X16 {
															_f0.X11 = int(_f0.X3)
														} else {
															switch {
															case _f.IP < 24:
																_f0.X17 = _f0.X12 ==
																	4
																_f.IP = 24
																fallthrough
															case _f.IP < 35:
																if _f0.X17 {
																	_f0.X11 = int(_f0.X4)
																} else {
																	switch {
																	case _f.IP < 26:
																		_f0.X18 = _f0.X12 ==
																			5
																		_f.IP = 26
																		fallthrough
																	case _f.IP < 35:
																		if _f0.X18 {
																			_f0.X11 = int(_f0.X5)
																		} else {
																			switch {
																			case _f.IP < 28:
																				_f0.X19 = _f0.X12 ==
																					6
																				_f.IP = 28
																				fallthrough
																			case _f.IP < 35:
																				if _f0.X19 {
																					_f0.X11 = int(_f0.X6)
																				} else {
																					switch {
																					case _f.IP < 30:
																						_f0.X20 = _f0.X12 ==
																							7
																						_f.IP = 30
																						fallthrough
																					case _f.IP < 35:
																						if _f0.X20 {
																							_f0.X11 = int(_f0.X7)
																						} else {
																							switch {
																							case _f.IP < 32:
																								_f0.X21 = _f0.X12 ==
																									8
																								_f.IP = 32
																								fallthrough
																							case _f.IP < 35:
																								if _f0.X21 {
																									_f0.X11 = int(_f0.X8)
																								} else {
																									switch {
																									case _f.IP < 34:
																										_f0.X22 = _f0.X12 ==
																											9
																										_f.IP = 34
																										fallthrough
																									case _f.IP < 35:
																										if _f0.X22 {
																											_f0.X11 = int(_f0.X9)
																										}
																									}
																								}
																							}
																						}
																					}
																				}
																			}
																		}
																	}
																}
															}
														}
													}
												}
											}
										}
									}
								}
							}
						}
					}
					_f.IP = 35
					fallthrough
				case _f.IP < 36:

					coroutine.Yield[int, any](_f0.X11)
				}
			}
		}
	}
}

//go:noinline
func Select(n int) {
	_c := coroutine.LoadContext[int, any]()
	_f, _fp := _c.Push()
	var _f0 *struct {
		X0  int
		X1  int
		X2  int
		X3  bool
		X4  int
		X5  bool
		X6  int
		X7  <-chan time.Time
		X8  <-chan time.Time
		X9  int
		X10 bool
		X11 bool
		X12 bool
		X13 int
		X14 <-chan time.Time
		X15 int
		X16 bool
		X17 bool
		X18 int
		X19 <-chan time.Time
		X20 int
		X21 bool
		X22 int
		X23 bool
	}
	if _f.IP == 0 {
		_f0 = &struct {
			X0  int
			X1  int
			X2  int
			X3  bool
			X4  int
			X5  bool
			X6  int
			X7  <-chan time.Time
			X8  <-chan time.Time
			X9  int
			X10 bool
			X11 bool
			X12 bool
			X13 int
			X14 <-chan time.Time
			X15 int
			X16 bool
			X17 bool
			X18 int
			X19 <-chan time.Time
			X20 int
			X21 bool
			X22 int
			X23 bool
		}{X0: n}
	} else {
		_f0 = _f.Get(0).(*struct {
			X0  int
			X1  int
			X2  int
			X3  bool
			X4  int
			X5  bool
			X6  int
			X7  <-chan time.Time
			X8  <-chan time.Time
			X9  int
			X10 bool
			X11 bool
			X12 bool
			X13 int
			X14 <-chan time.Time
			X15 int
			X16 bool
			X17 bool
			X18 int
			X19 <-chan time.Time
			X20 int
			X21 bool
			X22 int
			X23 bool
		})
	}
	defer func() {
		if _c.Unwinding() {
			_f.Set(0, _f0)
			_c.Store(_fp, _f)
		} else {
			_c.Pop()
		}
	}()
	switch {
	case _f.IP < 6:
		switch {
		case _f.IP < 2:
			_f0.X1 = 0
			_f.IP = 2
			fallthrough
		case _f.IP < 3:
			select {
			default:
				_f0.X1 = 1
			}
			_f.IP = 3
			fallthrough
		case _f.IP < 6:
			switch {
			case _f.IP < 4:
				_f0.X2 = _f0.X1
				_f.IP = 4
				fallthrough
			case _f.IP < 6:
				switch {
				default:
					switch {
					case _f.IP < 5:
						_f0.X3 = _f0.X2 == 1
						_f.IP = 5
						fallthrough
					case _f.IP < 6:
						if _f0.X3 {

							coroutine.Yield[int, any](-1)
						}
					}
				}
			}
		}
		_f.IP = 6
		fallthrough
	case _f.IP < 29:
		switch {
		case _f.IP < 7:
			_f0.X4 = 0
			_f.IP = 7
			fallthrough
		case _f.IP < 29:
		_l1:
			for ; ; _f0.X4, _f.IP = _f0.X4+1, 7 {
				switch {
				case _f.IP < 9:
					switch {
					case _f.IP < 8:
						_f0.X5 = !(_f0.X4 < _f0.X0)
						_f.IP = 8
						fallthrough
					case _f.IP < 9:
						if _f0.X5 {
							break _l1
						}
					}
					_f.IP = 9
					fallthrough
				case _f.IP < 21:
					switch {
					case _f.IP < 10:
						_f0.X6 = 0
						_f.IP = 10
						fallthrough
					case _f.IP < 11:
						_f0.X7 = time.After(0)
						_f.IP = 11
						fallthrough
					case _f.IP < 12:
						_f0.X8 = time.After(1 * time.Second)
						_f.IP = 12
						fallthrough
					case _f.IP < 14:
						select {
						case <-_f0.X7:
							_f0.X6 = 1
						case <-_f0.X8:
							_f0.X6 = 2
						}
						_f.IP = 14
						fallthrough
					case _f.IP < 21:
						switch {
						case _f.IP < 15:
							_f0.X9 = _f0.X6
							_f.IP = 15
							fallthrough
						case _f.IP < 21:
						_l2:
							switch {
							default:
								switch {
								case _f.IP < 16:
									_f0.X10 = _f0.X9 == 1
									_f.IP = 16
									fallthrough
								case _f.IP < 21:
									if _f0.X10 {
										switch {
										case _f.IP < 18:
											switch {
											case _f.IP < 17:
												_f0.X11 = _f0.X4 >=
													5
												_f.IP = 17
												fallthrough
											case _f.IP < 18:
												if _f0.X11 {
													break _l2
												}
											}
											_f.IP = 18
											fallthrough
										case _f.IP < 19:

											coroutine.Yield[int, any](_f0.X4)
										}
									} else {
										switch {
										case _f.IP < 20:
											_f0.X12 = _f0.X9 == 2
											_f.IP = 20
											fallthrough
										case _f.IP < 21:
											if _f0.X12 {

												panic("unreachable")
											}
										}
									}
								}
							}
						}
					}
					_f.IP = 21
					fallthrough
				case _f.IP < 29:
					switch {
					case _f.IP < 22:
						_f0.X13 = 0
						_f.IP = 22
						fallthrough
					case _f.IP < 23:
						_f0.X14 = time.After(0)
						_f.IP = 23
						fallthrough
					case _f.IP < 24:
						select {
						case <-_f0.X14:
							_f0.X13 = 1
						}
						_f.IP = 24
						fallthrough
					case _f.IP < 29:
						switch {
						case _f.IP < 25:
							_f0.X15 = _f0.X13
							_f.IP = 25
							fallthrough
						case _f.IP < 29:
						_l3:
							switch {
							default:
								switch {
								case _f.IP < 26:
									_f0.X16 = _f0.X15 == 1
									_f.IP = 26
									fallthrough
								case _f.IP < 29:
									if _f0.X16 {
										switch {
										case _f.IP < 28:
											switch {
											case _f.IP < 27:
												_f0.X17 = _f0.X4 >=
													6
												_f.IP = 27
												fallthrough
											case _f.IP < 28:
												if _f0.X17 {
													break _l3
												}
											}
											_f.IP = 28
											fallthrough
										case _f.IP < 29:

											coroutine.Yield[int, any](_f0.X4 * 10)
										}
									}
								}
							}
						}
					}
				}
			}
		}
		_f.IP = 29
		fallthrough
	case _f.IP < 38:
		switch {
		case _f.IP < 30:
			_f0.X18 = 0
			_f.IP = 30
			fallthrough
		case _f.IP < 31:
			_f0.X19 = time.After(0)
			_f.IP = 31
			fallthrough
		case _f.IP < 32:
			select {
			case <-_f0.X19:
				_f0.X18 = 1
			}
			_f.IP = 32
			fallthrough
		case _f.IP < 38:
			switch {
			case _f.IP < 33:
				_f0.X20 = _f0.X18
				_f.IP = 33
				fallthrough
			case _f.IP < 38:
				switch {
				default:
					switch {
					case _f.IP < 34:
						_f0.X21 = _f0.X20 == 1
						_f.IP = 34
						fallthrough
					case _f.IP < 38:
						if _f0.X21 {
							switch {
							case _f.IP < 35:
								_f0.X22 = 0
								_f.IP = 35
								fallthrough
							case _f.IP < 38:
							_l5:
								for ; ; _f0.X22, _f.IP = _f0.X22+1, 35 {
									switch {
									case _f.IP < 37:
										switch {
										case _f.IP < 36:
											_f0.X23 = !(_f0.X22 < 3)
											_f.IP = 36
											fallthrough
										case _f.IP < 37:
											if _f0.X23 {
												break _l5
											}
										}
										_f.IP = 37
										fallthrough
									case _f.IP < 38:
										coroutine.Yield[int, any](_f0.X22)
									}
								}
							}
						}
					}
				}
			}
		}
	}
}

//go:noinline
func YieldingExpressionDesugaring() {
	_c := coroutine.LoadContext[int, any]()
	_f, _fp := _c.Push()
	var _f0 *struct {
		X0  int
		X1  int
		X2  int
		X3  int
		X4  bool
		X5  int
		X6  int
		X7  int
		X8  int
		X9  int
		X10 bool
		X11 int
		X12 int
		X13 int
		X14 int
		X15 int
		X16 bool
		X17 int
		X18 int
		X19 int
		X20 int
		X21 bool
		X22 bool
		X23 int
		X24 int
		X25 int
		X26 int
		X27 int
		X28 bool
		X29 int
		X30 int
		X31 bool
		X32 int
		X33 int
		X34 int
		X35 bool
		X36 int
		X37 int
		X38 int
		X39 bool
		X40 int
		X41 int
		X42 any
	}
	if _f.IP == 0 {
		_f0 = &struct {
			X0  int
			X1  int
			X2  int
			X3  int
			X4  bool
			X5  int
			X6  int
			X7  int
			X8  int
			X9  int
			X10 bool
			X11 int
			X12 int
			X13 int
			X14 int
			X15 int
			X16 bool
			X17 int
			X18 int
			X19 int
			X20 int
			X21 bool
			X22 bool
			X23 int
			X24 int
			X25 int
			X26 int
			X27 int
			X28 bool
			X29 int
			X30 int
			X31 bool
			X32 int
			X33 int
			X34 int
			X35 bool
			X36 int
			X37 int
			X38 int
			X39 bool
			X40 int
			X41 int
			X42 any
		}{}
	} else {
		_f0 = _f.Get(0).(*struct {
			X0  int
			X1  int
			X2  int
			X3  int
			X4  bool
			X5  int
			X6  int
			X7  int
			X8  int
			X9  int
			X10 bool
			X11 int
			X12 int
			X13 int
			X14 int
			X15 int
			X16 bool
			X17 int
			X18 int
			X19 int
			X20 int
			X21 bool
			X22 bool
			X23 int
			X24 int
			X25 int
			X26 int
			X27 int
			X28 bool
			X29 int
			X30 int
			X31 bool
			X32 int
			X33 int
			X34 int
			X35 bool
			X36 int
			X37 int
			X38 int
			X39 bool
			X40 int
			X41 int
			X42 any
		})
	}
	defer func() {
		if _c.Unwinding() {
			_f.Set(0, _f0)
			_c.Store(_fp, _f)
		} else {
			_c.Pop()
		}
	}()
	switch {
	case _f.IP < 21:
		switch {
		case _f.IP < 2:
			_f0.X0 = b(1)
			_f.IP = 2
			fallthrough
		case _f.IP < 3:
			_f0.X1 = a(_f0.X0)
			_f.IP = 3
			fallthrough
		case _f.IP < 4:
			_f0.X2 = b(2)
			_f.IP = 4
			fallthrough
		case _f.IP < 5:
			_f0.X3 = a(_f0.X2)
			_f.IP = 5
			fallthrough
		case _f.IP < 6:
			_f0.X4 = _f0.X1 == _f0.X3
			_f.IP = 6
			fallthrough
		case _f.IP < 21:
			if _f0.X4 {
			} else {
				switch {
				case _f.IP < 8:
					_f0.X5 = b(3)
					_f.IP = 8
					fallthrough
				case _f.IP < 9:
					_f0.X6 = a(_f0.X5)
					_f.IP = 9
					fallthrough
				case _f.IP < 10:
					_f0.X7 = b(4)
					_f.IP = 10
					fallthrough
				case _f.IP < 11:
					_f0.X8 = a(_f0.X7)
					_f.IP = 11
					fallthrough
				case _f.IP < 12:
					_f0.X9 = _f0.X8 - 1
					_f.IP = 12
					fallthrough
				case _f.IP < 13:
					_f0.X10 = _f0.X6 == _f0.X9
					_f.IP = 13
					fallthrough
				case _f.IP < 21:
					if _f0.X10 {
						switch {
						case _f.IP < 14:
							_f0.X11 = b(5)
							_f.IP = 14
							fallthrough
						case _f.IP < 15:
							_f0.X12 = a(_f0.X11)
							_f.IP = 15
							fallthrough
						case _f.IP < 16:
							_f0.X13 = _f0.X12 * 10
							_f.IP = 16
							fallthrough
						case _f.IP < 17:
							coroutine.Yield[int, any](_f0.X13)
						}
					} else {
						switch {
						case _f.IP < 18:
							_f0.X14 = b(100)
							_f.IP = 18
							fallthrough
						case _f.IP < 19:
							_f0.X15 = a(_f0.X14)
							_f.IP = 19
							fallthrough
						case _f.IP < 20:
							_f0.X16 = _f0.X15 == 100
							_f.IP = 20
							fallthrough
						case _f.IP < 21:
							if _f0.X16 {
								panic("unreachable")
							}
						}
					}
				}
			}
		}
		_f.IP = 21
		fallthrough
	case _f.IP < 29:
		switch {
		case _f.IP < 22:
			_f0.X17 = b(6)
			_f.IP = 22
			fallthrough
		case _f.IP < 23:
			_f0.X18 = a(_f0.X17)
			_f.IP = 23
			fallthrough
		case _f.IP < 29:
		_l0:
			for ; ; _f0.X18, _f.IP = _f0.X18+1, 23 {
				switch {
				case _f.IP < 28:
					switch {
					case _f.IP < 24:
						_f0.X19 = b(8)
						_f.IP = 24
						fallthrough
					case _f.IP < 25:
						_f0.X20 = a(_f0.X19)
						_f.IP = 25
						fallthrough
					case _f.IP < 26:
						_f0.X21 = _f0.X18 < _f0.X20
						_f.IP = 26
						fallthrough
					case _f.IP < 27:
						_f0.X22 = !_f0.X21
						_f.IP = 27
						fallthrough
					case _f.IP < 28:
						if _f0.X22 {
							break _l0
						}
					}
					_f.IP = 28
					fallthrough
				case _f.IP < 29:
					coroutine.Yield[int, any](70)
				}
			}
		}
		_f.IP = 29
		fallthrough
	case _f.IP < 51:
		switch {
		case _f.IP < 30:
			_f0.X23 = b(9)
			_f.IP = 30
			fallthrough
		case _f.IP < 31:
			_f0.X24 = a(_f0.X23)
			_f.IP = 31
			fallthrough
		case _f.IP < 32:
			_f0.X25 = _f0.X24
			_f.IP = 32
			fallthrough
		case _f.IP < 51:
			switch {
			default:
				switch {
				case _f.IP < 33:
					_f0.X26 = b(10)
					_f.IP = 33
					fallthrough
				case _f.IP < 34:
					_f0.X27 = a(_f0.X26)
					_f.IP = 34
					fallthrough
				case _f.IP < 35:
					_f0.X28 = _f0.X25 == _f0.X27
					_f.IP = 35
					fallthrough
				case _f.IP < 51:
					if _f0.X28 {
						panic("unreachable")
					} else {
						switch {
						case _f.IP < 37:
							_f0.X29 = b(11)
							_f.IP = 37
							fallthrough
						case _f.IP < 38:
							_f0.X30 = a(_f0.X29)
							_f.IP = 38
							fallthrough
						case _f.IP < 39:
							_f0.X31 = _f0.X25 == _f0.X30
							_f.IP = 39
							fallthrough
						case _f.IP < 51:
							if _f0.X31 {
								panic("unreachable")
							} else {
								switch {
								case _f.IP < 41:
									_f0.X32 = b(12)
									_f.IP = 41
									fallthrough
								case _f.IP < 42:
									_f0.X33 = a(_f0.X32)
									_f.IP = 42
									fallthrough
								case _f.IP < 43:
									_f0.X34 = _f0.X33 - 3
									_f.IP = 43
									fallthrough
								case _f.IP < 44:
									_f0.X35 = _f0.X25 == _f0.X34
									_f.IP = 44
									fallthrough
								case _f.IP < 51:
									if _f0.X35 {
										switch {
										case _f.IP < 45:
											_f0.X36 = b(13)
											_f.IP = 45
											fallthrough
										case _f.IP < 46:
											a(_f0.X36)
										}
									} else {
										switch {
										case _f.IP < 47:
											_f0.X37 = b(14)
											_f.IP = 47
											fallthrough
										case _f.IP < 48:
											_f0.X38 = a(_f0.X37)
											_f.IP = 48
											fallthrough
										case _f.IP < 49:
											_f0.X39 = _f0.X25 == _f0.X38
											_f.IP = 49
											fallthrough
										case _f.IP < 51:
											if _f0.X39 {
												panic("unreachable")
											} else {
												panic("unreachable")
											}
										}
									}
								}
							}
						}
					}
				}
			}
		}
		_f.IP = 51
		fallthrough
	case _f.IP < 57:
		switch {
		case _f.IP < 52:
			_f0.X40 = b(15)
			_f.IP = 52
			fallthrough
		case _f.IP < 53:
			_f0.X41 = a(_f0.X40)
			_f.IP = 53
			fallthrough
		case _f.IP < 54:
			_f0.X42 = any(_f0.X41)
			_f.IP = 54
			fallthrough
		case _f.IP < 57:
			switch x := _f0.X42.(type) {
			case bool:
				panic("unreachable")
			case int:
				coroutine.Yield[int, any](x * 10)
			default:

				panic("unreachable")
			}
		}
	}
}

//go:noinline
func a(v int) (_ int) {
	_c := coroutine.LoadContext[int, any]()
	_f, _fp := _c.Push()
	var _f0 *struct {
		X0 int
	}
	if _f.IP == 0 {
		_f0 = &struct {
			X0 int
		}{X0: v}
	} else {
		_f0 = _f.Get(0).(*struct {
			X0 int
		})
	}
	defer func() {
		if _c.Unwinding() {
			_f.Set(0, _f0)
			_c.Store(_fp, _f)
		} else {
			_c.Pop()
		}
	}()
	switch {
	case _f.IP < 2:
		coroutine.Yield[int, any](_f0.X0)
		_f.IP = 2
		fallthrough
	case _f.IP < 3:
		return _f0.X0
	}
	return
}

//go:noinline
func b(v int) (_ int) {
	_c := coroutine.LoadContext[int, any]()
	_f, _fp := _c.Push()
	var _f0 *struct {
		X0 int
	}
	if _f.IP == 0 {
		_f0 = &struct {
			X0 int
		}{X0: v}
	} else {
		_f0 = _f.Get(0).(*struct {
			X0 int
		})
	}
	defer func() {
		if _c.Unwinding() {
			_f.Set(0, _f0)
			_c.Store(_fp, _f)
		} else {
			_c.Pop()
		}
	}()
	switch {
	case _f.IP < 2:
		coroutine.Yield[int, any](-_f0.X0)
		_f.IP = 2
		fallthrough
	case _f.IP < 3:
		return _f0.X0
	}
	return
}
